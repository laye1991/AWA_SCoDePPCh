import type { Express, Request, Response, NextFunction } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { db } from "./db";
import { z } from "zod";
import { User, hunters, guardians, history } from "@shared/schema";
import { eq, desc } from "drizzle-orm";

// √âtendre l'interface Request pour inclure l'utilisateur
declare global {
  namespace Express {
    interface Request {
      user?: User;
    }
  }
}

import {
  insertHunterSchema,
  insertPermitSchema,
  insertTaxSchema,
  insertHistorySchema,
  insertUserSchema,
  insertMessageSchema,
  insertGroupMessageSchema,
  insertHuntingGuideSchema,
  createHuntingGuideWithUserSchema,
  insertGuardianSchema,
  insertHuntingCampaignSchema,
  huntingCampaigns,
  huntingGuides
} from "@shared/schema";

// Middleware d'authentification
const isAuthenticated = async (req: Request, res: Response, next: NextFunction) => {
  // V√©rifier si l'utilisateur est connect√© dans la session ou dans req.user
  const sessionUser = req.session.user;
  const currentUser = sessionUser || req.user;
  
  if (!currentUser) {
    console.log("Aucun utilisateur connect√© dans le middleware isAuthenticated");
    return res.status(401).json({ message: "Vous devez √™tre connect√© pour acc√©der √† cette ressource" });
  }
  
  // Assigner l'utilisateur √† req.user pour les autres middleware
  req.user = currentUser;
  
  next();
};

// Middleware pour v√©rifier si l'utilisateur est admin
const isAdmin = async (req: Request, res: Response, next: NextFunction) => {
  // V√©rifier d'abord que l'utilisateur est authentifi√©
  await isAuthenticated(req, res, () => {
    // Ensuite v√©rifier si l'utilisateur est un administrateur
    if (req.user?.role !== 'admin') {
      return res.status(403).json({ message: "Acc√®s refus√©. Seuls les administrateurs peuvent acc√©der √† cette ressource." });
    }
    next();
  });
};

export async function registerRoutes(app: Express): Promise<Server> {
  // Authentication routes
  app.post("/api/auth/login", async (req, res) => {
    try {
      const { username, password } = req.body;
      
      if (!username || !password) {
        return res.status(400).json({ message: "Le nom d'utilisateur et le mot de passe sont requis" });
      }
      
      // V√©rifier d'abord si l'utilisateur existe dans la base de donn√©es
      const userDb = await storage.getUserByUsername(username);
      
      if (!userDb) {
        console.log(`Tentative de connexion avec un nom d'utilisateur inexistant: ${username}`);
        return res.status(401).json({ message: "Identifiants incorrects" });
      }
      
      // V√©rifier si le mot de passe correspond
      if (userDb.password !== password) {
        console.log(`Mot de passe incorrect pour l'utilisateur ${username}`);
        return res.status(401).json({ message: "Identifiants incorrects" });
      }
      
      // V√©rifier si le compte est actif
      if (!userDb.isActive) {
        return res.status(403).json({ message: "Ce compte a √©t√© d√©sactiv√©. Veuillez contacter un administrateur." });
      }
      
      // Pr√©parer les informations utilisateur (sans le mot de passe)
      const userInfo = {
        id: userDb.id,
        username: userDb.username,
        email: userDb.email,
        firstName: userDb.firstName,
        lastName: userDb.lastName,
        phone: userDb.phone,
        matricule: userDb.matricule,
        serviceLocation: userDb.serviceLocation,
        assignmentPost: userDb.assignmentPost,
        region: userDb.region,
        role: userDb.role,
        hunterId: userDb.hunterId,
        isActive: userDb.isActive,
        createdAt: userDb.createdAt
      };
      
      // Pour les utilisateurs de type chasseur, r√©cup√©rer √©galement les informations du chasseur
      if (userDb.role === 'hunter' && userDb.hunterId) {
        try {
          const hunterInfo = await storage.getHunter(userDb.hunterId);
          if (hunterInfo) {
            // Ajouter les informations du chasseur √† la r√©ponse et √† l'utilisateur
            Object.assign(userInfo, {
              firstName: hunterInfo.firstName,
              lastName: hunterInfo.lastName,
              hunter: hunterInfo
            });
          }
        } catch (hunterError) {
          console.error(`Erreur lors de la r√©cup√©ration des infos du chasseur pour l'utilisateur ${username}:`, hunterError);
        }
      }
      
      // Stocker l'utilisateur dans la session
      req.session.user = userInfo;
      
      // Enregistrer l'activit√© de connexion dans l'historique
      await storage.createHistory({
        userId: userDb.id,
        operation: "login",
        entityType: "user",
        entityId: userDb.id,
        details: `Connexion de l'utilisateur ${userDb.username}`
      });
      
      console.log(`Connexion r√©ussie pour l'utilisateur ${username}, r√¥le: ${userDb.role}`);
      res.json({ user: userInfo });
    } catch (error) {
      console.error("Erreur lors de la connexion:", error);
      res.status(500).json({ message: "√âchec de la connexion" });
    }
  });
  
  app.post("/api/auth/logout", (req, res) => {
    // D√©truire la session
    req.session.destroy((err) => {
      if (err) {
        console.error("Erreur lors de la destruction de la session:", err);
        return res.status(500).json({ message: "Erreur lors de la d√©connexion" });
      }
      res.json({ message: "D√©connexion r√©ussie" });
    });
  });
  
  app.get("/api/auth/me", async (req, res) => {
    // R√©cup√©rer l'utilisateur de la session
    const sessionUser = req.session.user;
    
    // Si l'utilisateur n'est pas en session, essayer de le r√©cup√©rer via l'en-t√™te d'autorisation
    // comme m√©thode de secours (pour compatibilit√©)
    if (!sessionUser) {
      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.json(null);
      }
      
      try {
        // Extraire l'identifiant (supposons que le format est "Bearer username")
        const parts = authHeader.split(' ');
        if (parts.length !== 2 || parts[0] !== 'Bearer') {
          return res.json(null);
        }
        
        const username = parts[1];
        
        // R√©cup√©rer l'utilisateur √† partir de la base de donn√©es
        const user = await storage.getUserByUsername(username);
        
        if (!user) {
          return res.json(null);
        }
        
        // Ne pas retourner le mot de passe
        const { password, ...userInfo } = user;
        
        // Pour les utilisateurs de type chasseur, r√©cup√©rer √©galement les informations du chasseur
        if (user.role === 'hunter' && user.hunterId) {
          try {
            const hunterInfo = await storage.getHunter(user.hunterId);
            if (hunterInfo) {
              // Ajouter les informations du chasseur √† la r√©ponse
              Object.assign(userInfo, {
                hunter: hunterInfo,
                firstName: hunterInfo.firstName,
                lastName: hunterInfo.lastName
              });
            }
          } catch (hunterError) {
            console.error(`Erreur lors de la r√©cup√©ration des infos du chasseur pour l'utilisateur ${username}:`, hunterError);
          }
        }
        
        // Stocker l'utilisateur dans la session pour les prochaines requ√™tes
        req.session.user = userInfo as User;
        
        return res.json(userInfo);
      } catch (error) {
        console.error("Erreur lors de la r√©cup√©ration de l'utilisateur via l'en-t√™te:", error);
        return res.json(null);
      }
    }
    
    // Si l'utilisateur est d√©j√† en session, retourner directement
    res.json(sessionUser);
  });
  // Hunter API routes
  app.get("/api/hunters", async (req, res) => {
    try {
      console.log("Tentative de r√©cup√©ration de tous les chasseurs");
      const hunters = await storage.getAllHunters();
      console.log(`${hunters.length} chasseurs trouv√©s`);
      res.json(hunters);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des chasseurs:", error);
      res.status(500).json({ message: "Failed to retrieve hunters" });
    }
  });
  
  // Route pour r√©cup√©rer les chasseurs d'une r√©gion sp√©cifique
  app.get("/api/hunters/region/:region", isAuthenticated, async (req, res) => {
    try {
      // V√©rifier que l'utilisateur est un administrateur, un agent ou un agent secteur
      if (req.user?.role !== "admin" && req.user?.role !== "agent" && req.user?.role !== "sub-agent") {
        return res.status(403).json({ message: "Acc√®s non autoris√©" });
      }
      
      const region = req.params.region;
      if (!region) {
        return res.status(400).json({ message: "R√©gion non sp√©cifi√©e" });
      }
      
      // Si l'utilisateur est un agent r√©gional, v√©rifier que la r√©gion correspond √† sa r√©gion
      if (req.user.role === "agent" && req.user.region && req.user.region !== region) {
        return res.status(403).json({ message: "Vous n'avez pas acc√®s aux chasseurs de cette r√©gion" });
      }
      
      const hunters = await storage.getHuntersByRegion(region);
      res.json(hunters);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des chasseurs par r√©gion:", error);
      res.status(500).json({ message: "Erreur lors de la r√©cup√©ration des chasseurs par r√©gion" });
    }
  });
  
  // Route pour r√©cup√©rer les chasseurs d'une zone sp√©cifique
  app.get("/api/hunters/zone/:zone", isAuthenticated, async (req, res) => {
    try {
      // V√©rifier que l'utilisateur est un administrateur, un agent ou un agent secteur
      if (req.user?.role !== "admin" && req.user?.role !== "agent" && req.user?.role !== "sub-agent") {
        return res.status(403).json({ message: "Acc√®s non autoris√©" });
      }
      
      const zone = req.params.zone;
      if (!zone) {
        return res.status(400).json({ message: "Zone non sp√©cifi√©e" });
      }
      
      // Si l'utilisateur est un agent secteur, v√©rifier que la zone correspond √† sa zone
      if (req.user.role === "sub-agent" && req.user.zone && req.user.zone !== zone) {
        return res.status(403).json({ message: "Vous n'avez pas acc√®s aux chasseurs de cette zone" });
      }
      
      const hunters = await storage.getHuntersByZone(zone);
      res.json(hunters);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des chasseurs par zone:", error);
      res.status(500).json({ message: "Erreur lors de la r√©cup√©ration des chasseurs par zone" });
    }
  });
  
  // Route pour r√©cup√©rer les informations du chasseur connect√©
  app.get("/api/hunters/me", async (req, res) => {
    try {
      // V√©rifier si nous avons l'utilisateur dans la session
      const sessionUser = req.session.user;
      
      // Logging pour d√©bogage
      console.log("Requ√™te /api/hunters/me - User dans la session:", sessionUser);
      
      // Si pas d'utilisateur dans la session, essayer req.user (qui est peupl√© par le middleware)
      const currentUser = sessionUser || req.user;
      
      if (!currentUser) {
        console.log("Aucun utilisateur trouv√© dans la session ou dans req.user");
        return res.status(401).json({ message: "Utilisateur non authentifi√©" });
      }
      
      if (!currentUser.hunterId) {
        console.log("L'utilisateur n'a pas de hunterId:", currentUser.username);
        return res.status(404).json({ message: "Aucun chasseur associ√© √† ce compte utilisateur" });
      }
      
      console.log("Recherche du chasseur avec ID:", currentUser.hunterId);
      const hunter = await storage.getHunter(currentUser.hunterId);
      
      if (!hunter) {
        console.log("Chasseur non trouv√© avec l'ID:", currentUser.hunterId);
        return res.status(404).json({ message: "Chasseur non trouv√©" });
      }
      
      console.log("Chasseur trouv√©:", hunter.lastName, hunter.firstName);
      res.json(hunter);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration du chasseur:", error);
      res.status(500).json({ message: "Failed to retrieve hunter" });
    }
  });
  
  // Supprimer la duplication du middleware d'authentification qui a d√©j√† √©t√© d√©fini en haut du fichier

  app.get("/api/hunters/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      console.log(`R√©cup√©ration des d√©tails du chasseur avec ID: ${id}`);
      const hunter = await storage.getHunter(id);
      if (!hunter) {
        console.log(`Aucun chasseur trouv√© avec l'ID: ${id}`);
        return res.status(404).json({ message: "Hunter not found" });
      }
      console.log(`D√©tails du chasseur r√©cup√©r√©s:`, hunter);
      res.json(hunter);
    } catch (error) {
      console.error(`Erreur lors de la r√©cup√©ration du chasseur:`, error);
      res.status(500).json({ message: "Failed to retrieve hunter" });
    }
  });

  app.post("/api/hunters", async (req, res) => {
    try {
      // D√©bogage des donn√©es re√ßues
      console.log("Donn√©es re√ßues pour cr√©ation de chasseur:", JSON.stringify(req.body, null, 2));
      
      // Assurons-nous que le champ phone a une valeur par d√©faut si null
      let hunterData = req.body;
      if (hunterData.phone === null || hunterData.phone === undefined) {
        hunterData.phone = ""; // Remplace null par une cha√Æne vide
      }
      
      // S'assurer que nationality est d√©finie si pays est pr√©sent
      if (hunterData.pays && (!hunterData.nationality || hunterData.nationality === "")) {
        hunterData.nationality = hunterData.pays;
        console.log("Attribution de la nationalit√© bas√©e sur le pays:", hunterData.nationality);
      }
      
      // Garder la cat√©gorie telle quelle, puisque nous utilisons maintenant 'touriste'
      console.log("Cat√©gorie du chasseur:", hunterData.category);

      const validatedData = insertHunterSchema.parse(hunterData);

      // Check if hunter with same ID number exists
      const existingHunter = await storage.getHunterByIdNumber(validatedData.idNumber);
      if (existingHunter) {
        return res.status(400).json({ message: "Chasseur avec ce num√©ro d'identit√© existe d√©j√†" });
      }

      // Ajouter des logs pour diagnostiquer les erreurs
      console.log("Donn√©es de chasseur valid√©es:", validatedData);
      
      try {
        const hunter = await storage.createHunter(validatedData);
        console.log("Chasseur cr√©√© avec succ√®s:", hunter);

        // Pr√©parer un message SMS pour le nouveau chasseur si le num√©ro de t√©l√©phone est fourni
        if (hunter.phone) {
          const smsMessage = `Bienvenue sur SIGPE! Votre compte de chasseur a √©t√© cr√©√© avec succ√®s. Identifiant: ${hunter.idNumber}. Vous pouvez maintenant demander un permis de chasse.`;
          
          // Stocker le message dans l'historique pour pouvoir l'envoyer plus tard
          await storage.createHistory({
            operation: "sms_notification",
            entityType: "hunter", 
            entityId: hunter.id,
            details: `SMS notification for hunter: ${hunter.lastName} ${hunter.firstName} to phone ${hunter.phone}: ${smsMessage}`
          });
          
          console.log(`SMS notification prepared for new hunter ${hunter.lastName} ${hunter.firstName} to phone ${hunter.phone}`);
        }

        // Add history record
        await storage.createHistory({
          operation: "create",
          entityType: "hunter",
          entityId: hunter.id,
          details: `Created hunter: ${hunter.lastName} ${hunter.firstName}`,
        });

        res.status(201).json(hunter);
      } catch (storageError) {
        console.error("Erreur lors de la cr√©ation du chasseur dans le stockage:", storageError);
        throw storageError; // Propager l'erreur pour avoir des d√©tails
      }
    } catch (error) {
      console.error("Erreur d√©taill√©e lors de la cr√©ation du chasseur:", error);
      
      if (error instanceof z.ZodError) {
        return res.status(400).json({ 
          message: "Donn√©es de chasseur invalides", 
          errors: error.errors 
        });
      }
      
      res.status(500).json({ 
        message: "√âchec de la cr√©ation du chasseur",
        error: error.message || String(error)
      });
    }
  });

  // Route pour mettre √† jour uniquement les informations d'√©quipement du chasseur
  app.patch("/api/hunters/:id/equipment", isAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const hunterData = req.body;
      
      // V√©rifier si l'utilisateur connect√© est le propri√©taire du profil ou un administrateur
      const hunter = await storage.getHunter(id);
      
      if (!hunter) {
        return res.status(404).json({ message: "Chasseur non trouv√©" });
      }
      
      // V√©rifier si l'utilisateur a les droits (soit admin soit propri√©taire) 
      if (req.user?.role !== "admin" && req.user?.id !== hunter.userId) {
        return res.status(403).json({ message: "Vous n'avez pas l'autorisation de modifier ce profil" });
      }
      
      // Ne permettre que la mise √† jour des champs d'√©quipement
      const equipmentData = {
        weaponType: hunterData.weaponType,
        weaponBrand: hunterData.weaponBrand,
        customWeaponBrand: hunterData.customWeaponBrand,
        weaponReference: hunterData.weaponReference,
        weaponCaliber: hunterData.weaponCaliber,
        weaponOtherDetails: hunterData.weaponOtherDetails
      };
      
      // Mettre √† jour uniquement les informations d'√©quipement
      await storage.updateHunter(id, equipmentData);
      
      res.status(200).json({ message: "Informations d'√©quipement mises √† jour avec succ√®s" });
    } catch (error) {
      console.error("Erreur lors de la mise √† jour de l'√©quipement:", error);
      res.status(500).json({ message: "Erreur lors de la mise √† jour de l'√©quipement" });
    }
  });

  app.put("/api/hunters/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      let hunterData = req.body;
      
      // Traitement sp√©cial pour la nationalit√© et le pays
      if (hunterData.pays && (!hunterData.nationality || hunterData.nationality === "")) {
        hunterData.nationality = hunterData.pays;
        console.log("Mise √† jour: Attribution de la nationalit√© bas√©e sur le pays:", hunterData.nationality);
      }
      
      // Garder la cat√©gorie telle quelle, puisque nous utilisons maintenant 'touriste'
      console.log("Mise √† jour: Cat√©gorie du chasseur:", hunterData.category);
      
      // V√©rification sp√©cifique pour le traitement du statut mineur
      if (hunterData.isMinor !== undefined) {
        console.log("Mise √† jour du statut mineur du chasseur:", hunterData.isMinor);
      }
      
      const validatedData = insertHunterSchema.partial().parse(hunterData);

      const hunter = await storage.getHunter(id);
      if (!hunter) {
        return res.status(404).json({ message: "Hunter not found" });
      }

      // Check if ID number is changed and if it's already in use
      if (validatedData.idNumber && validatedData.idNumber !== hunter.idNumber) {
        const existingHunter = await storage.getHunterByIdNumber(validatedData.idNumber);
        if (existingHunter && existingHunter.id !== id) {
          return res.status(400).json({ message: "ID number already in use by another hunter" });
        }
      }

      // Ajout du support pour la mise √† jour du champ isMinor
      if (hunterData.isMinor !== undefined) {
        // Validation du type pour s'assurer que isMinor est un bool√©en
        if (typeof hunterData.isMinor !== 'boolean') {
          return res.status(400).json({ message: "Le champ isMinor doit √™tre un bool√©en" });
        }
        
        // Utiliser directement la mise √† jour via Drizzle pour contourner les restrictions du sch√©ma
        const { db } = await import("./db");
        const { hunters } = await import("@shared/schema");
        const { eq } = await import("drizzle-orm");
        
        const result = await db.update(hunters)
          .set({ isMinor: hunterData.isMinor })
          .where(eq(hunters.id, id))
          .returning();
          
        if (result.length === 0) {
          return res.status(500).json({ message: "√âchec de la mise √† jour du statut mineur du chasseur" });
        }
        
        // Cr√©er une entr√©e dans l'historique sp√©cifique au changement de statut
        await storage.createHistory({
          operation: "update_minor_status",
          entityType: "hunter",
          entityId: id,
          details: `Statut mineur du chasseur modifi√©: ${hunterData.isMinor ? "Mineur" : "Adulte"}`,
        });
        
        return res.json(result[0]);
      }

      // Pour les autres mises √† jour (qui ne concernent pas le statut mineur)
      const updatedHunter = await storage.updateHunter(id, validatedData);

      // Add history record
      await storage.createHistory({
        operation: "update",
        entityType: "hunter",
        entityId: id,
        details: `Updated hunter: ${updatedHunter!.lastName} ${updatedHunter!.firstName}`,
      });

      res.json(updatedHunter);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid hunter data", errors: error.errors });
      }
      console.error("Erreur lors de la mise √† jour du chasseur:", error);
      res.status(500).json({ message: "Failed to update hunter" });
    }
  });

  app.delete("/api/hunters/:id", isAuthenticated, async (req, res) => {
    try {
      console.log("üìù D√©but de la route de suppression du chasseur");
      
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        console.error("‚ùå ID de chasseur invalide:", req.params.id);
        return res.status(400).json({ message: "ID de chasseur invalide" });
      }
      
      // V√©rifier si la suppression forc√©e est demand√©e
      const forceDelete = req.query.force === 'true';
      
      console.log(`üîç Tentative de suppression du chasseur avec ID: ${id}, force=${forceDelete}`);
      console.log(`üë§ Utilisateur demandant la suppression: ${req.user?.username} (${req.user?.role})`);

      // V√©rifier que l'utilisateur est un admin ou un agent
      if (req.user?.role !== "admin" && req.user?.role !== "agent") {
        console.error(`‚ùå Acc√®s refus√© pour l'utilisateur ${req.user?.username} avec le r√¥le ${req.user?.role}`);
        return res.status(403).json({ message: "Acc√®s refus√©. Seuls les administrateurs et agents peuvent supprimer des chasseurs." });
      }

      const hunter = await storage.getHunter(id);
      if (!hunter) {
        console.error(`‚ùå Chasseur avec ID ${id} non trouv√©`);
        return res.status(404).json({ message: "Chasseur non trouv√©" });
      }
      
      console.log(`‚úÖ Chasseur trouv√©: ${hunter.firstName} ${hunter.lastName}`);
      
      // Pour les administrateurs, on force toujours la suppression
      // Pour les agents, seulement si force=true est sp√©cifi√©
      const shouldForce = req.user?.role === 'admin' || forceDelete;
      
      console.log(`üîÑ For√ßage de la suppression? ${shouldForce}`);

      // Appel √† la m√©thode de suppression du chasseur
      console.log(`üóëÔ∏è Appel de la m√©thode deleteHunter pour l'ID ${id} avec force=${shouldForce}`);
      const deleted = await storage.deleteHunter(id, shouldForce);
      
      if (!deleted) {
        console.error(`‚ùå La m√©thode deleteHunter a retourn√© false pour l'ID ${id}`);
        return res.status(500).json({ 
          message: "Erreur serveur lors de la suppression du chasseur."
        });
      }
      
      console.log(`‚úÖ Suppression r√©ussie du chasseur ${id}`);

      // Add history record
      try {
        console.log(`üìù Ajout d'une entr√©e d'historique pour la suppression du chasseur ${id}`);
        await storage.createHistory({
          userId: req.user?.id,
          operation: "delete",
          entityType: "hunter",
          entityId: id,
          details: `Chasseur supprim√©: ${hunter.lastName} ${hunter.firstName}`,
        });
        console.log(`‚úÖ Entr√©e d'historique cr√©√©e avec succ√®s`);
      } catch (historyError) {
        console.error(`‚ö†Ô∏è Erreur lors de la cr√©ation de l'entr√©e d'historique:`, historyError);
        // On continue malgr√© l'erreur d'historique
      }

      console.log(`üéâ Suppression du chasseur ${id} compl√©t√©e avec succ√®s`);
      res.status(200).json({ message: "Chasseur supprim√© avec succ√®s" });
    } catch (error) {
      console.error("‚ùå Erreur lors de la suppression du chasseur:", error);
      
      // Log plus d√©taill√© de l'erreur
      if (error instanceof Error) {
        console.error("Type d'erreur:", error.name);
        console.error("Message d'erreur:", error.message);
        console.error("Stack trace:", error.stack);
      }
      
      res.status(500).json({ 
        message: "√âchec de la suppression du chasseur",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });
  
  // Route pour suspendre un chasseur
  app.patch("/api/hunters/:id/suspend", isAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      
      // V√©rifier que l'utilisateur est un admin ou un agent
      if (req.user?.role !== "admin" && req.user?.role !== "agent") {
        return res.status(403).json({ message: "Acc√®s refus√©. Seuls les administrateurs et agents peuvent suspendre un chasseur." });
      }
      
      if (isNaN(id)) {
        return res.status(400).json({ message: "ID chasseur invalide" });
      }
      
      console.log(`üîí Tentative de suspension du chasseur ${id}`);
      
      // Suspendre le chasseur
      const suspendedHunter = await storage.suspendHunter(id);
      
      if (!suspendedHunter) {
        return res.status(404).json({ message: "Chasseur non trouv√© ou impossible √† suspendre" });
      }
      
      // Enregistrer l'action dans l'historique
      try {
        await storage.createHistory({
          userId: req.user?.id,
          operation: "suspend",
          entityType: "hunter",
          entityId: id,
          details: `Chasseur suspendu: ${suspendedHunter.firstName} ${suspendedHunter.lastName} (ID: ${id})`,
        });
        console.log(`‚úÖ Entr√©e d'historique cr√©√©e`);
      } catch (historyError) {
        console.error(`‚ö†Ô∏è Erreur lors de la cr√©ation de l'entr√©e d'historique:`, historyError);
      }
      
      return res.json({ 
        message: "Chasseur suspendu avec succ√®s", 
        hunter: suspendedHunter 
      });
    } catch (error) {
      console.error("Erreur lors de la suspension du chasseur:", error);
      return res.status(500).json({
        message: "√âchec de la suspension du chasseur",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });
  
  // Route pour r√©activer un chasseur
  app.patch("/api/hunters/:id/reactivate", isAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      
      // V√©rifier que l'utilisateur est un admin ou un agent
      if (req.user?.role !== "admin" && req.user?.role !== "agent") {
        return res.status(403).json({ message: "Acc√®s refus√©. Seuls les administrateurs et agents peuvent r√©activer des chasseurs." });
      }

      const hunter = await storage.getHunter(id);
      if (!hunter) {
        return res.status(404).json({ message: "Chasseur non trouv√©" });
      }
      
      // Mettre √† jour le chasseur pour le marquer comme actif
      // On met √† jour directement dans la base de donn√©es avec l'attribut isActive qui existe dans le sch√©ma
      const result = await db.update(hunters)
        .set({ isActive: true })
        .where(eq(hunters.id, id))
        .returning();
      
      const updatedHunter = result[0];
      
      if (!updatedHunter) {
        return res.status(500).json({ message: "√âchec de la r√©activation du chasseur" });
      }
      
      // Ajouter une entr√©e dans l'historique
      await storage.createHistory({
        userId: req.user?.id,
        operation: "reactivate",
        entityType: "hunter",
        entityId: id,
        details: `Chasseur r√©activ√©: ${hunter.lastName} ${hunter.firstName}`,
      });
      
      res.status(200).json({ message: "Chasseur r√©activ√© avec succ√®s", hunter: updatedHunter });
    } catch (error) {
      console.error("Erreur lors de la r√©activation du chasseur:", error);
      res.status(500).json({ message: "√âchec de la r√©activation du chasseur" });
    }
  });

  // Route pour v√©rifier si un ID de chasseur existe
  app.get("/api/hunters/check-id/:idNumber", async (req, res) => {
    try {
      const { idNumber } = req.params;
      const hunter = await storage.getHunterByIdNumber(idNumber);
      // R√©pondre uniquement avec JSON (pas de HTML)
      res.json({ exists: !!hunter });
    } catch (error) {
      console.error("Erreur lors de la v√©rification de l'ID du chasseur:", error);
      res.status(500).json({ error: "Erreur lors de la v√©rification" });
    }
  });
  
  // Route pour r√©cup√©rer les chasseurs mineurs
  app.get("/api/hunters/minors", isAuthenticated, async (req, res) => {
    try {
      // V√©rifier les permissions (seul un admin ou agent peut voir les chasseurs mineurs)
      if (req.user?.role !== "admin" && req.user?.role !== "agent") {
        return res.status(403).json({ message: "Acc√®s refus√©. Seuls les administrateurs et agents peuvent voir la liste des chasseurs mineurs." });
      }
      
      // Utiliser directement Drizzle pour r√©cup√©rer les chasseurs avec isMinor = true
      const { db } = await import("./db");
      const { hunters } = await import("@shared/schema");
      const { eq } = await import("drizzle-orm");
      
      const minorHunters = await db.select()
        .from(hunters)
        .where(eq(hunters.isMinor, true));
      
      res.json(minorHunters);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des chasseurs mineurs:", error);
      res.status(500).json({ message: "√âchec de la r√©cup√©ration des chasseurs mineurs" });
    }
  });
  
  app.get("/api/hunters/search/idNumber/:idNumber", async (req, res) => {
    try {
      const idNumber = req.params.idNumber;
      const hunter = await storage.getHunterByIdNumber(idNumber);
      if (!hunter) {
        return res.status(404).json({ message: "Hunter not found" });
      }
      res.json(hunter);
    } catch (error) {
      res.status(500).json({ message: "Failed to search hunter" });
    }
  });

  app.get("/api/hunters/search/phone/:phone", async (req, res) => {
    try {
      const phone = req.params.phone;
      const hunter = await storage.getHunterByPhone(phone);
      if (!hunter) {
        return res.status(404).json({ message: "Hunter not found" });
      }
      res.json(hunter);
    } catch (error) {
      res.status(500).json({ message: "Failed to search hunter" });
    }
  });

  // Les routes API pour les tuteurs des chasseurs mineurs ont √©t√© retir√©es
  
  // Les routes pour la gestion des chasseurs mineurs et leurs tuteurs ont √©t√© retir√©es

  // Permit API routes
  app.get("/api/permits", async (req, res) => {
    try {
      const permits = await storage.getAllPermits();
      res.json(permits);
    } catch (error) {
      res.status(500).json({ message: "Failed to retrieve permits" });
    }
  });
  
  // Route pour r√©cup√©rer tous les permis suspendus
  app.get("/api/permits/suspended", isAuthenticated, async (req, res) => {
    try {
      // V√©rifier que l'utilisateur est un admin ou un agent
      if (req.user?.role !== "admin" && req.user?.role !== "agent") {
        return res.status(403).json({ message: "Acc√®s refus√©. Seuls les administrateurs et agents peuvent g√©rer les permis suspendus." });
      }
      
      const suspendedPermits = await storage.getSuspendedPermits();
      res.json(suspendedPermits);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des permis suspendus:", error);
      res.status(500).json({ message: "Impossible de r√©cup√©rer les permis suspendus" });
    }
  });
  
  // Route pour supprimer tous les permis suspendus en une seule op√©ration
  app.delete("/api/permits/suspended/all", isAuthenticated, async (req, res) => {
    try {
      // V√©rifier que l'utilisateur est un admin
      if (req.user?.role !== "admin") {
        return res.status(403).json({ message: "Acc√®s refus√©. Seuls les administrateurs peuvent supprimer des permis en masse." });
      }
      
      console.log("Tentative de suppression en masse des permis suspendus");
      
      // R√©cup√©rer tous les permis suspendus d'abord
      const suspendedPermits = await storage.getSuspendedPermits();
      
      if (suspendedPermits.length === 0) {
        return res.status(404).json({ message: "Aucun permis suspendu √† supprimer" });
      }
      
      const { permits, taxes } = await import("@shared/schema");
      const { eq } = await import("drizzle-orm");
      const { db } = await import("./db");
      
      let successCount = 0;
      let failureCount = 0;
      
      // Supprimer chaque permis suspendu
      for (const permit of suspendedPermits) {
        try {
          // 1. Supprimer les taxes associ√©es (si elles existent)
          try {
            const deletedTaxes = await db.delete(taxes)
              .where(eq(taxes.permitId, permit.id))
              .returning();
            console.log(`Permis ${permit.id}: ${deletedTaxes.length} taxes supprim√©es`);
          } catch (taxError) {
            console.error(`Erreur lors de la suppression des taxes du permis ${permit.id}:`, taxError);
          }
          
          // 2. Supprimer le permis
          const result = await db.delete(permits)
            .where(eq(permits.id, permit.id))
            .returning();
          
          if (result.length > 0) {
            successCount++;
            // Enregistrer l'action dans l'historique
            await storage.createHistory({
              userId: req.user?.id,
              operation: "delete",
              entityType: "permit",
              entityId: permit.id,
              details: `Permis ${permit.permitNumber} supprim√© (suppression de groupe)`
            });
          } else {
            failureCount++;
          }
        } catch (permitError) {
          console.error(`Erreur lors de la suppression du permis ${permit.id}:`, permitError);
          failureCount++;
        }
      }
      
      return res.status(200).json({
        message: `Suppression termin√©e. ${successCount} permis supprim√©s, ${failureCount} √©checs.`,
        successCount,
        failureCount,
        totalCount: suspendedPermits.length
      });
    } catch (error) {
      console.error("Erreur lors de la suppression en masse des permis suspendus:", error);
      res.status(500).json({
        message: "Erreur lors de la suppression en masse des permis",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });
  
  // Route pour supprimer un groupe de permis sp√©cifique par leurs IDs
  app.delete("/api/permits/batch", isAuthenticated, async (req, res) => {
    try {
      // V√©rifier que l'utilisateur est un admin
      if (req.user?.role !== "admin") {
        return res.status(403).json({ message: "Acc√®s refus√©. Seuls les administrateurs peuvent supprimer des permis en groupe." });
      }
      
      // V√©rifier que le corps de la requ√™te contient un tableau d'IDs
      const permitIds = req.body.permitIds;
      if (!Array.isArray(permitIds) || permitIds.length === 0) {
        return res.status(400).json({ message: "La requ√™te doit contenir un tableau non-vide d'IDs de permis" });
      }
      
      console.log(`Tentative de suppression en groupe de ${permitIds.length} permis`);
      
      const { permits, taxes } = await import("@shared/schema");
      const { eq, inArray } = await import("drizzle-orm");
      const { db } = await import("./db");
      
      // R√©cup√©rer les informations sur les permis avant de les supprimer
      const permitsToDelete = await db.select()
        .from(permits)
        .where(inArray(permits.id, permitIds));
      
      if (permitsToDelete.length === 0) {
        return res.status(404).json({ message: "Aucun permis trouv√© avec les IDs fournis" });
      }
      
      // 1. Supprimer d'abord toutes les taxes associ√©es
      try {
        const deletedTaxes = await db.delete(taxes)
          .where(inArray(taxes.permitId, permitIds))
          .returning();
        console.log(`${deletedTaxes.length} taxes supprim√©es pour le lot de permis`);
      } catch (taxError) {
        console.error("Erreur lors de la suppression en groupe des taxes associ√©es:", taxError);
      }
      
      // 2. Supprimer les permis
      const deletedPermits = await db.delete(permits)
        .where(inArray(permits.id, permitIds))
        .returning();
      
      // 3. Enregistrer l'action dans l'historique pour chaque permis supprim√©
      for (const permit of permitsToDelete) {
        try {
          await storage.createHistory({
            userId: req.user?.id,
            operation: "delete",
            entityType: "permit",
            entityId: permit.id,
            details: `Permis ${permit.permitNumber} supprim√© (suppression par lot)`
          });
        } catch (historyError) {
          console.error(`Erreur lors de la cr√©ation de l'historique pour le permis ${permit.id}:`, historyError);
        }
      }
      
      return res.status(200).json({
        message: `${deletedPermits.length} permis supprim√©s avec succ√®s`,
        deletedCount: deletedPermits.length,
        totalRequested: permitIds.length
      });
    } catch (error) {
      console.error("Erreur lors de la suppression en groupe des permis:", error);
      res.status(500).json({
        message: "Erreur lors de la suppression en groupe des permis",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });

  app.get("/api/permits/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const permit = await storage.getPermit(id);
      if (!permit) {
        return res.status(404).json({ message: "Permit not found" });
      }
      res.json(permit);
    } catch (error) {
      res.status(500).json({ message: "Failed to retrieve permit" });
    }
  });

  app.delete("/api/permits/:id", isAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      console.log("FORCER LA SUPPRESSION - Permis ID:", id);
      
      const permit = await storage.getPermit(id);
      if (!permit) {
        return res.status(404).json({ message: "Permis non trouv√©" });
      }

      // Utilisation de drizzle directement pour forcer la suppression
      const { permits, taxes } = await import("@shared/schema");
      const { eq } = await import("drizzle-orm");
      const { db } = await import("./db");
      
      // 1. Supprimer d'abord toutes les taxes associ√©es (si elles existent)
      try {
        const deletedTaxes = await db.delete(taxes)
          .where(eq(taxes.permitId, id))
          .returning();
        console.log(`Suppression forc√©e: ${deletedTaxes.length} taxes supprim√©es pour le permis ID ${id}`);
      } catch (taxError) {
        console.error("Erreur lors de la suppression des taxes associ√©es (ignorant):", taxError);
      }
      
      // 2. Forcer la suppression du permis
      const result = await db.delete(permits)
        .where(eq(permits.id, id))
        .returning();

      console.log("R√©sultat de la suppression forc√©e:", result);
      
      if (result.length > 0) {
        // Cr√©er une entr√©e d'historique pour la suppression
        await storage.createHistory({
          userId: req.user?.id,
          operation: "delete",
          entityType: "permit",
          entityId: id,
          details: `Permis ${permit.permitNumber} supprim√© (FORCE)`
        });
        
        return res.status(200).json({ message: "Permis supprim√© avec succ√®s (FORCE)" });
      } else {
        return res.status(404).json({ message: "Permis non trouv√© ou d√©j√† supprim√©" });
      }
    } catch (error) {
      console.error("Error deleting permit:", error);
      res.status(500).json({ message: "Erreur lors de la suppression du permis" });
    }
  });

  app.get("/api/permits/hunter/:hunterId", async (req, res) => {
    try {
      const hunterId = parseInt(req.params.hunterId);
      const permits = await storage.getPermitsByHunterId(hunterId);
      res.json(permits);
    } catch (error) {
      res.status(500).json({ message: "Failed to retrieve permits" });
    }
  });

  app.get("/api/permits/number/:permitNumber", async (req, res) => {
    try {
      const permitNumber = req.params.permitNumber;
      const permit = await storage.getPermitByNumber(permitNumber);
      if (!permit) {
        return res.status(404).json({ message: "Permit not found" });
      }
      res.json(permit);
    } catch (error) {
      res.status(500).json({ message: "Failed to retrieve permit" });
    }
  });

  app.post("/api/permits", async (req, res) => {
    try {
      console.log("Received permit creation request:", req.body);

      // Check if hunter exists first
      const hunterId = parseInt(req.body.hunterId);
      const hunter = await storage.getHunter(hunterId);
      if (!hunter) {
        return res.status(400).json({ message: "Chasseur non trouv√©" });
      }
      
      // V√©rification si le chasseur est suspendu
      const userRecord = await storage.getUserByHunterId(hunterId);
      if (userRecord && userRecord.isSuspended) {
        return res.status(400).json({ message: "Ce chasseur est suspendu et ne peut pas recevoir de nouveaux permis" });
      }

      // Check if permit number already exists
      const existingPermit = await storage.getPermitByNumber(req.body.permitNumber);
      if (existingPermit) {
        return res.status(400).json({ message: "Ce num√©ro de permis existe d√©j√†" });
      }
      
      // V√©rifier si le chasseur poss√®de d√©j√† un permis du m√™me type
      const permitType = req.body.type;
      if (!permitType) {
        return res.status(400).json({ message: "Le type de permis est obligatoire" });
      }
      
      // R√©cup√©rer tous les permis actifs du chasseur
      const activePermits = await storage.getActivePermitsByHunterId(hunterId);
      
      // V√©rifier si un permis du m√™me type existe d√©j√†
      const hasPermitOfSameType = activePermits.some(permit => permit.type === permitType);
      if (hasPermitOfSameType) {
        return res.status(400).json({ 
          message: `Le chasseur poss√®de d√©j√† un permis actif de type '${permitType}'. Un chasseur ne peut avoir qu'un seul permis par type.`
        });
      }

      // Validate data with zod schema
      try {
        // R√©cup√©rer les param√®tres de la campagne de chasse pour utiliser la date de fermeture
        const campaignSettings = await storage.getHuntingCampaignSettings();
        if (!campaignSettings) {
          return res.status(500).json({ message: "Impossible de r√©cup√©rer les param√®tres de la campagne de chasse" });
        }
        
        // Calculer la date d'expiration √† partir de la date d'√©mission (1 an)
        const issueDate = new Date(req.body.issueDate);
        const oneYearLater = new Date(issueDate);
        oneYearLater.setFullYear(oneYearLater.getFullYear() + 1);
        
        // Si la date de fermeture de la campagne est ant√©rieure √† 1 an, utiliser celle-ci
        const campaignEndDate = new Date(campaignSettings.endDate);
        const expiryDate = campaignEndDate < oneYearLater ? campaignEndDate : oneYearLater;
        
        const validatedData = insertPermitSchema.parse({
          permitNumber: req.body.permitNumber,
          hunterId: hunterId,
          issueDate: req.body.issueDate,
          // Utiliser la date d'expiration calcul√©e (1 an apr√®s √©mission ou date de fin de campagne au plus t√¥t)
          expiryDate: expiryDate.toISOString().split('T')[0],
          status: "active",
          price: req.body.price,
          createdAt: new Date().toISOString().split('T')[0],
          type: permitType,
          receiptNumber: req.body.receiptNumber || null,
          area: req.body.area || null,
          weapons: req.body.weapons || null
        });

        console.log("Validated permit data with campaign end date:", validatedData);
        
        // Create the permit using validated data
        const permit = await storage.createPermit(validatedData);

        // Add history record
        await storage.createHistory({
          operation: "create",
          entityType: "permit",
          entityId: permit.id,
          details: `Permis cr√©√©: ${permit.permitNumber} pour ${hunter.firstName} ${hunter.lastName} (Type: ${permitType})`,
        });

        console.log("Permit created successfully:", permit);
        res.status(201).json(permit);
      } catch (validationError) {
        console.error("Permit validation error:", validationError);
        if (validationError instanceof z.ZodError) {
          return res.status(400).json({ 
            message: "Erreur de validation des donn√©es du permis", 
            errors: validationError.errors 
          });
        }
        throw validationError;
      }
    } catch (error) {
      console.error("Permit creation error:", error);
      res.status(500).json({ 
        message: "√âchec de la cr√©ation du permis",
        error: error instanceof Error ? error.message : "Erreur inconnue"
      });
    }
  });

  app.patch("/api/permits/:id/renew", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      
      // R√©cup√©rer le permis pour conna√Ætre sa date d'expiration actuelle
      const permit = await storage.getPermit(id);
      if (!permit) {
        return res.status(404).json({ message: "Permis non trouv√©" });
      }
      
      // Calculer la nouvelle date d'expiration (1 an apr√®s la date d'expiration actuelle)
      const currentExpiry = new Date(permit.expiryDate);
      const expiryDate = new Date(currentExpiry);
      expiryDate.setFullYear(expiryDate.getFullYear() + 1);
      
      // R√©cup√©rer √©galement la date de fin de campagne pour s'assurer de ne pas la d√©passer
      const campaignSettings = await storage.getHuntingCampaignSettings();
      if (campaignSettings) {
        const campaignEndDate = new Date(campaignSettings.endDate);
        // Si la date de fin de campagne est ant√©rieure √† la nouvelle date d'expiration, utiliser celle-ci
        if (campaignEndDate < expiryDate) {
          expiryDate.setTime(campaignEndDate.getTime());
        }
      }
      
      // V√©rifier que le permis existe
      const permit = await storage.getPermit(id);
      if (!permit) {
        return res.status(404).json({ message: "Permis non trouv√©" });
      }

      const renewedPermit = await storage.renewPermit(id, expiryDate);

      // Add history record
      await storage.createHistory({
        operation: "renew",
        entityType: "permit",
        entityId: id,
        details: `Permis renouvel√©: ${renewedPermit!.permitNumber} jusqu'au ${expiryDate.toISOString().split('T')[0]}`,
      });

      res.json(renewedPermit);
    } catch (error) {
      console.error("Erreur lors du renouvellement du permis:", error);
      res.status(500).json({ message: "√âchec du renouvellement du permis" });
    }
  });

  app.patch("/api/permits/:id/suspend", isAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      console.log("FORCER LA SUSPENSION - Permis ID:", id);

      // Utilisation de drizzle directement pour forcer la mise √† jour
      const { permits } = await import("@shared/schema");
      const { eq } = await import("drizzle-orm");
      const { db } = await import("./db");
      
      // Forcer la mise √† jour sans v√©rification
      const result = await db.update(permits)
        .set({ status: 'suspended' })
        .where(eq(permits.id, id))
        .returning();

      if (!result || result.length === 0) {
        return res.status(404).json({ message: "Permis non trouv√© ou suspension impossible" });
      }
      
      const suspendedPermit = result[0];
      console.log("Suspension forc√©e r√©ussie:", suspendedPermit);

      // Add history record
      await storage.createHistory({
        userId: req.user?.id,
        operation: "suspend",
        entityType: "permit",
        entityId: id,
        details: `Permis suspendu (force): ${suspendedPermit.permitNumber}`,
      });

      return res.json(suspendedPermit);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error("Erreur lors de la suspension forc√©e du permis:", errorMessage);
      return res.status(500).json({ 
        message: "√âchec de la suspension du permis",
        error: errorMessage
      });
    }
  });
  
  // Endpoint pour l'√©volution d'un permis de Petite Chasse vers Grande Chasse
  app.patch("/api/permits/:id/upgrade", isAuthenticated, async (req, res) => {
    try {
      // V√©rifier les permissions (seul un admin ou un agent peut faire √©voluer un permis)
      if (req.user?.role !== "admin" && req.user?.role !== "agent") {
        return res.status(403).json({ message: "Acc√®s refus√©. Seuls les administrateurs et agents peuvent faire √©voluer un permis." });
      }
      
      const id = parseInt(req.params.id);
      
      // Validation des donn√©es de la requ√™te
      const upgradeDataSchema = z.object({
        additionalPrice: z.number().min(0, "Le prix suppl√©mentaire doit √™tre positif ou nul"),
        newType: z.enum(["Grande Chasse"], { errorMap: () => ({ message: "Le type doit √™tre 'Grande Chasse'" })})
      });
      
      // Valider les donn√©es de la requ√™te
      const { additionalPrice, newType } = upgradeDataSchema.parse(req.body);
      
      // V√©rifier que le permis existe
      const permit = await storage.getPermit(id);
      if (!permit) {
        return res.status(404).json({ message: "Permis non trouv√©" });
      }
      
      // V√©rifier que le permis est de type Petite Chasse
      if (permit.type !== "Petite Chasse") {
        return res.status(400).json({ 
          message: "Seuls les permis de type 'Petite Chasse' peuvent √©voluer vers 'Grande Chasse'" 
        });
      }
      
      // V√©rifier que le permis est actif
      if (permit.status !== "active") {
        return res.status(400).json({ 
          message: "Seuls les permis actifs peuvent √™tre mis √† jour" 
        });
      }
      
      // R√©cup√©rer les informations du chasseur
      const hunter = await storage.getHunter(permit.hunterId);
      if (!hunter) {
        return res.status(404).json({ message: "Chasseur non trouv√©" });
      }
      
      // V√©rifier que le chasseur n'a pas d√©j√† un permis de Grande Chasse
      const allPermits = await storage.getActivePermitsByHunterId(permit.hunterId);
      const hasGrandeChasse = allPermits.some(p => p.type === "Grande Chasse" && p.id !== id);
      
      if (hasGrandeChasse) {
        return res.status(400).json({ 
          message: "Le chasseur poss√®de d√©j√† un permis de Grande Chasse actif" 
        });
      }
      
      // Faire √©voluer le permis
      const upgradedPermit = await storage.upgradePermit(id, newType, additionalPrice);
      
      if (!upgradedPermit) {
        return res.status(500).json({ message: "Erreur lors de la mise √† jour du permis" });
      }
      
      // Enregistrer dans l'historique
      await storage.createHistory({
        userId: req.user?.id,
        operation: "upgrade",
        entityType: "permit",
        entityId: id,
        details: `√âvolution du permis ${permit.permitNumber} de '${permit.type}' vers '${newType}' pour ${hunter.firstName} ${hunter.lastName}. Prix suppl√©mentaire: ${additionalPrice}`
      });
      
      res.status(200).json({
        message: "Permis mis √† jour avec succ√®s",
        permit: upgradedPermit
      });
    } catch (error) {
      console.error("Erreur lors de l'√©volution du permis:", error);
      
      if (error instanceof z.ZodError) {
        return res.status(400).json({ 
          message: "Donn√©es invalides pour l'√©volution du permis",
          errors: error.errors
        });
      }
      
      res.status(500).json({ 
        message: "√âchec de l'√©volution du permis",
        error: error instanceof Error ? error.message : "Erreur inconnue"
      });
    }
  });

  // Route pour supprimer un groupe de permis sp√©cifiques par leurs IDs
  app.post("/api/permits/batch/delete", isAuthenticated, async (req, res) => {
    try {
      const { permitIds } = req.body;
      
      if (!permitIds || !Array.isArray(permitIds) || permitIds.length === 0) {
        return res.status(400).json({ message: "Veuillez fournir un tableau d'identifiants de permis √† supprimer" });
      }
      
      console.log(`Tentative de suppression de ${permitIds.length} permis:`, permitIds);
      
      // V√©rifier que l'utilisateur a les autorisations n√©cessaires
      if (req.user?.role !== "admin" && req.user?.role !== "agent") {
        return res.status(403).json({ message: "Acc√®s refus√©. Seuls les administrateurs et agents peuvent supprimer des permis." });
      }
      
      const { permits, taxes } = await import("@shared/schema");
      const { eq, inArray } = await import("drizzle-orm");
      const { db } = await import("./db");
      
      let successCount = 0;
      let failureCount = 0;
      
      // R√©cup√©rer d'abord les d√©tails des permis pour l'historique
      const permitsToDelete = await db.select().from(permits)
        .where(inArray(permits.id, permitIds));
      
      if (permitsToDelete.length === 0) {
        return res.status(404).json({ message: "Aucun des permis sp√©cifi√©s n'a √©t√© trouv√©" });
      }
      
      // Supprimer les taxes associ√©es d'abord
      try {
        await db.delete(taxes)
          .where(inArray(taxes.permitId, permitIds));
      } catch (taxError) {
        console.error(`Erreur lors de la suppression des taxes associ√©es:`, taxError);
      }
      
      // Supprimer les permis
      try {
        const result = await db.delete(permits)
          .where(inArray(permits.id, permitIds))
          .returning();
        
        successCount = result.length;
        failureCount = permitIds.length - successCount;
        
        // Enregistrer l'action dans l'historique pour chaque permis supprim√©
        for (const permit of permitsToDelete) {
          try {
            await storage.createHistory({
              userId: req.user?.id,
              operation: "delete",
              entityType: "permit",
              entityId: permit.id,
              details: `Permis ${permit.permitNumber} supprim√© (suppression en lot)`
            });
          } catch (historyError) {
            console.error(`Erreur lors de l'enregistrement de l'historique pour le permis ${permit.id}:`, historyError);
          }
        }
      } catch (deleteError) {
        console.error("Erreur lors de la suppression des permis:", deleteError);
        return res.status(500).json({
          message: "Erreur lors de la suppression des permis",
          error: deleteError instanceof Error ? deleteError.message : String(deleteError)
        });
      }
      
      return res.status(200).json({
        message: `Suppression termin√©e. ${successCount} permis supprim√©s, ${failureCount} √©checs.`,
        successCount,
        failureCount,
        totalCount: permitIds.length
      });
    } catch (error) {
      console.error("Erreur lors de la suppression en lot des permis:", error);
      res.status(500).json({
        message: "Erreur lors de la suppression en lot des permis",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });

  // Tax API routes
  app.get("/api/taxes", async (req, res) => {
    try {
      const taxes = await storage.getAllTaxes();
      res.json(taxes);
    } catch (error) {
      res.status(500).json({ message: "Failed to retrieve taxes" });
    }
  });

  app.get("/api/taxes/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const tax = await storage.getTax(id);
      if (!tax) {
        return res.status(404).json({ message: "Tax not found" });
      }
      res.json(tax);
    } catch (error) {
      res.status(500).json({ message: "Failed to retrieve tax" });
    }
  });

  app.get("/api/taxes/hunter/:hunterId", async (req, res) => {
    try {
      const hunterId = parseInt(req.params.hunterId);
      const taxes = await storage.getTaxesByHunterId(hunterId);
      res.json(taxes);
    } catch (error) {
      res.status(500).json({ message: "Failed to retrieve taxes" });
    }
  });

  app.post("/api/taxes", async (req, res) => {
    try {
      const validatedData = insertTaxSchema.parse(req.body);

      // Check if hunter exists
      const hunter = await storage.getHunter(validatedData.hunterId);
      if (!hunter) {
        return res.status(400).json({ message: "Hunter not found" });
      }

      // Check if permit exists
      const permit = await storage.getPermit(validatedData.permitId);
      if (!permit) {
        return res.status(400).json({ message: "Permis non trouv√©" });
      }

      // Ensure permit is active
      if (permit.status !== 'active') {
        return res.status(400).json({ message: "Le permis n'est pas actif" });
      }

      const tax = await storage.createTax(validatedData);

      // Add history record
      await storage.createHistory({
        operation: "create",
        entityType: "tax",
        entityId: tax.id,
        details: `Created tax: ${tax.taxNumber} for hunter ID ${hunter.id}`,
      });

      res.status(201).json(tax);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid tax data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create tax" });
    }
  });

  // History API routes
  app.get("/api/history", async (req, res) => {
    try {
      const history = await storage.getAllHistory();
      res.json(history);
    } catch (error) {
      res.status(500).json({ message: "Failed to retrieve history" });
    }
  });

  app.get("/api/history/:entityType/:entityId", async (req, res) => {
    try {
      const entityType = req.params.entityType;
      const entityId = parseInt(req.params.entityId);
      const history = await storage.getHistoryByEntityId(entityId, entityType);
      res.json(history);
    } catch (error) {
      res.status(500).json({ message: "Failed to retrieve history" });
    }
  });

  app.post("/api/history/clear", async (req, res) => {
    try {
      await storage.clearHistory();

      // Cr√©er une nouvelle entr√©e d'historique pour enregistrer l'effacement
      await storage.createHistory({
        operation: "delete",
        entityType: "system",
        entityId: 0,
        details: "Historique effac√© par l'administrateur",
      });

      res.status(200).json({ message: "L'historique a √©t√© effac√© avec succ√®s" });
    } catch (error) {
      console.error("Error clearing history:", error);
      res.status(500).json({ message: "√âchec de l'effacement de l'historique" });
    }
  });

  // Route pour r√©cup√©rer tous les agents (uniquement les utilisateurs avec r√¥le agent)
  app.get("/api/users/agents", async (req, res) => {
    try {
      // R√©cup√©rer tous les utilisateurs
      const users = await storage.getAllUsers();
      
      // Filtrer pour ne garder que les agents
      const agents = users.filter(user => user.role === "agent");
      
      // Supprimer les mots de passe avant de renvoyer la r√©ponse
      const agentsWithoutPassword = agents.map(agent => {
        const { password, ...agentWithoutPassword } = agent;
        return agentWithoutPassword;
      });
      
      return res.json(agentsWithoutPassword);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des agents:", error);
      return res.status(500).json({ message: "√âchec de la r√©cup√©ration des agents" });
    }
  });

  // Revenue management
  app.post("/api/revenues/clear", async (req, res) => {
    try {
      await storage.clearRevenues();

      // Cr√©er une nouvelle entr√©e d'historique pour enregistrer l'effacement des recettes
      await storage.createHistory({
        operation: "delete",
        entityType: "revenue",
        entityId: 0,
        details: "Recettes effac√©es par l'administrateur",
      });

      res.status(200).json({ message: "Les recettes ont √©t√© effac√©es avec succ√®s" });
    } catch (error) {
      console.error("Error clearing revenues:", error);
      res.status(500).json({ message: "√âchec de l'effacement des recettes" });
    }
  });

  // Stats API route
  let statsCache = {
    data: null,
    timestamp: 0
  };

  app.get("/api/stats", async (req, res) => {
    try {
      const now = Date.now();
      // Cache valide pendant 25 secondes
      if (statsCache.data && now - statsCache.timestamp < 25000) {
        return res.json(statsCache.data);
      }

      const stats = await storage.getStats();
      
      // Ajouter les informations de la campagne en cours
      const campaignSettings = await storage.getHuntingCampaignSettings();
      
      const fullStats = {
        ...stats,
        campaignSettings
      };
      
      statsCache = {
        data: fullStats,
        timestamp: now
      };
      
      res.json(fullStats);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des statistiques:", error);
      res.status(500).json({ message: "Failed to retrieve stats" });
    }
  });

  // Stats pour graphiques
  app.get("/api/stats/permits-by-month", async (req, res) => {
    try {
      const permitsByMonth = await storage.getPermitsByMonth();
      res.json(permitsByMonth);
    } catch (error) {
      console.error("Error retrieving permits by month:", error);
      res.status(500).json({ message: "Failed to retrieve permits by month statistics" });
    }
  });
  
  // Endpoint pour r√©cup√©rer l'historique des activit√©s
  app.get("/api/history", isAuthenticated, async (req, res) => {
    try {
      // R√©cup√©rer l'historique depuis la base de donn√©es
      const historyData = await db.select().from(history).orderBy(desc(history.createdAt));
      return res.json(historyData);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration de l'historique:", error);
      return res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Endpoint pour effacer l'historique (option r√©serv√©e aux administrateurs)
  app.post("/api/history/clear", isAuthenticated, async (req, res) => {
    // V√©rifier que l'utilisateur est un administrateur
    if (req.user?.role !== 'admin') {
      return res.status(403).json({ message: "Acc√®s refus√©. Seuls les administrateurs peuvent effacer l'historique." });
    }
    try {
      // Dans une implementation r√©elle, ceci supprimerait ou archiverait les donn√©es
      // Pour l'exemple, nous retournons simplement un message de succ√®s
      return res.json({ message: "L'historique a √©t√© effac√© avec succ√®s" });
    } catch (error) {
      console.error("Erreur lors de la suppression de l'historique:", error);
      return res.status(500).json({ message: "Erreur serveur" });
    }
  });
  
  // Endpoints pour les demandes de permis
  app.post("/api/permit-requests", async (req, res) => {
    try {
      const permitRequest = await storage.createPermitRequest(req.body);
      
      // Cr√©er une entr√©e dans l'historique
      await storage.createHistory({
        entityId: permitRequest.id,
        entityType: "permit_request",
        operation: "create",
        userId: req.body.userId,
        details: `Nouvelle demande de permis de chasse cr√©√©e`
      });
      
      res.status(201).json(permitRequest);
    } catch (error) {
      console.error("Error creating permit request:", error);
      res.status(500).json({ message: "Erreur lors de la cr√©ation de la demande de permis" });
    }
  });

  // Obtenir les permis actifs d'un chasseur
  app.get("/api/permits/hunter/:id/active", async (req, res) => {
    try {
      const hunterId = parseInt(req.params.id);
      
      if (isNaN(hunterId)) {
        return res.status(400).json({ message: "ID de chasseur invalide" });
      }
      
      const permits = await storage.getActivePermitsByHunterId(hunterId);
      res.json(permits);
    } catch (error) {
      console.error("Error retrieving active permits:", error);
      res.status(500).json({ message: "Erreur lors de la r√©cup√©ration des permis actifs" });
    }
  });

  app.get("/api/stats/revenue-by-type", async (req, res) => {
    try {
      const revenueStats = await storage.getRevenueByType();
      res.json(revenueStats);
    } catch (error) {
      console.error("Error retrieving revenue by type:", error);
      res.status(500).json({ message: "Failed to retrieve revenue statistics" });
    }
  });

  app.get("/api/stats/tax-distribution", async (req, res) => {
    try {
      const taxStats = await storage.getTaxDistribution();
      res.json(taxStats);
    } catch (error) {
      console.error("Error retrieving tax distribution:", error);
      res.status(500).json({ message: "Failed to retrieve tax distribution statistics" });
    }
  });

  // Routes pour g√©rer les campagnes cyn√©g√©tiques
  app.get("/api/huntingCampaign", async (req, res) => {
    try {
      const campaignSettings = await storage.getHuntingCampaignSettings();
      res.json(campaignSettings);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des param√®tres de campagne:", error);
      res.status(500).json({ message: "Erreur lors de la r√©cup√©ration des param√®tres de campagne" });
    }
  });
  
  app.post("/api/huntingCampaign", isAdmin, async (req, res) => {
    try {
      const { startDate, endDate, year, isActive } = req.body;
      
      if (!startDate || !endDate || !year) {
        return res.status(400).json({ message: "Les dates de d√©but et de fin ainsi que l'ann√©e sont requises" });
      }
      
      const savedSettings = await storage.saveHuntingCampaignSettings({
        startDate,
        endDate,
        year,
        isActive
      });
      
      // Enregistrer dans l'historique
      await storage.createHistory({
        userId: req.user?.id || 0,
        operation: "update",
        entityType: "hunting_campaign",
        entityId: 0, // ID fictif car nous utilisons la derni√®re campagne
        details: `Mise √† jour des param√®tres de campagne cyn√©g√©tique ${year} (${new Date(startDate).toLocaleDateString()} - ${new Date(endDate).toLocaleDateString()})`
      });
      
      res.json(savedSettings);
    } catch (error) {
      console.error("Erreur lors de la sauvegarde des param√®tres de campagne:", error);
      res.status(500).json({ message: "Erreur lors de la sauvegarde des param√®tres de campagne" });
    }
  });

  // ID Sequencing API routes
  app.get("/api/sequence/:table/next", isAuthenticated, async (req, res) => {
    try {
      // V√©rifier que l'utilisateur est un admin ou un agent
      if (req.user?.role !== "admin" && req.user?.role !== "agent") {
        return res.status(403).json({ message: "Acc√®s refus√©. Seuls les administrateurs et les agents peuvent acc√©der √† cette ressource." });
      }
      
      const tableName = req.params.table;
      // Liste des tables autoris√©es
      const allowedTables = ['hunters', 'permits', 'taxes', 'hunting_reports', 'hunting_guides'];
      
      if (!allowedTables.includes(tableName)) {
        return res.status(400).json({ message: "Table non autoris√©e pour la gestion des s√©quences." });
      }
      
      // V√©rifier si la m√©thode getNextAvailableId existe sur storage
      if (typeof storage.getNextAvailableId !== 'function') {
        console.error("M√©thode getNextAvailableId non impl√©ment√©e");
        return res.status(500).json({ message: "Fonctionnalit√© en cours d'impl√©mentation" });
      }
      
      const nextId = await storage.getNextAvailableId(tableName);
      res.json({ table: tableName, nextId });
    } catch (error) {
      console.error(`Erreur lors de la r√©cup√©ration du prochain ID pour ${req.params.table}:`, error);
      res.status(500).json({ message: "√âchec de la r√©cup√©ration du prochain ID." });
    }
  });
  
  app.post("/api/sequence/:table/resequence", isAuthenticated, async (req, res) => {
    try {
      // V√©rifier que l'utilisateur est un admin
      if (req.user?.role !== "admin") {
        return res.status(403).json({ message: "Acc√®s refus√©. Seuls les administrateurs peuvent r√©organiser les s√©quences d'ID." });
      }
      
      const tableName = req.params.table;
      // Liste des tables autoris√©es
      const allowedTables = ['hunters', 'permits', 'taxes', 'hunting_reports', 'hunting_guides'];
      
      if (!allowedTables.includes(tableName)) {
        return res.status(400).json({ message: "Table non autoris√©e pour la r√©organisation des s√©quences." });
      }
      
      // V√©rifier si la m√©thode resequenceIds existe sur storage
      if (typeof storage.resequenceIds !== 'function') {
        console.error("M√©thode resequenceIds non impl√©ment√©e");
        return res.status(500).json({ message: "Fonctionnalit√© en cours d'impl√©mentation" });
      }
      
      await storage.resequenceIds(tableName);
      
      // Ajouter une entr√©e √† l'historique
      await storage.createHistory({
        userId: req.user.id,
        operation: "resequence",
        entityType: "table",
        entityId: 0, // Pas d'ID sp√©cifique pour cette op√©ration
        details: `R√©organisation des IDs de la table ${tableName}`
      });
      
      res.json({ message: `S√©quence d'IDs de la table ${tableName} r√©organis√©e avec succ√®s.` });
    } catch (error) {
      console.error(`Erreur lors de la r√©organisation des IDs pour ${req.params.table}:`, error);
      res.status(500).json({ message: "√âchec de la r√©organisation des IDs." });
    }
  });
  
  // Messages API routes (pour la messagerie interne)
  app.get("/api/messages", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user!.id;
      
      // V√©rifier si la m√©thode getMessageThreads existe sur storage
      if (typeof storage.getMessageThreads !== 'function') {
        console.error("M√©thode getMessageThreads non impl√©ment√©e");
        return res.status(500).json({ message: "Fonctionnalit√© en cours d'impl√©mentation" });
      }
      
      const threads = await storage.getMessageThreads(userId);
      res.json(threads);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des messages:", error);
      res.status(500).json({ message: "√âchec de la r√©cup√©ration des messages" });
    }
  });
  
  app.get("/api/messages/:id", isAuthenticated, async (req, res) => {
    try {
      const messageId = parseInt(req.params.id);
      if (isNaN(messageId)) {
        return res.status(400).json({ message: "ID de message invalide" });
      }
      
      const message = await storage.getMessageWithSender(messageId);
      if (!message) {
        return res.status(404).json({ message: "Message non trouv√©" });
      }
      
      // V√©rifier que l'utilisateur a acc√®s √† ce message
      const userId = req.user!.id;
      if (message.senderId !== userId && message.recipientId !== userId) {
        return res.status(403).json({ message: "Vous n'avez pas acc√®s √† ce message" });
      }
      
      // Si l'utilisateur est le destinataire et que le message n'est pas encore lu, le marquer comme lu
      if (message.recipientId === userId && !message.isRead) {
        await storage.markMessageAsRead(messageId);
      }
      
      res.json(message);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration du message:", error);
      res.status(500).json({ message: "√âchec de la r√©cup√©ration du message" });
    }
  });
  
  app.get("/api/messages/thread/:id", isAuthenticated, async (req, res) => {
    try {
      const threadId = parseInt(req.params.id);
      if (isNaN(threadId)) {
        return res.status(400).json({ message: "ID de conversation invalide" });
      }
      
      const thread = await storage.getMessageThread(threadId);
      if (!thread || thread.length === 0) {
        return res.status(404).json({ message: "Conversation non trouv√©e" });
      }
      
      // V√©rifier que l'utilisateur a acc√®s √† cette conversation
      const userId = req.user!.id;
      const parentMessage = thread[0]; // Le premier message est le parent
      
      if (parentMessage.senderId !== userId && parentMessage.recipientId !== userId) {
        return res.status(403).json({ message: "Vous n'avez pas acc√®s √† cette conversation" });
      }
      
      // Marquer tous les messages non lus comme lus si l'utilisateur est le destinataire
      for (const message of thread) {
        if (message.recipientId === userId && !message.isRead) {
          await storage.markMessageAsRead(message.id);
        }
      }
      
      res.json(thread);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration de la conversation:", error);
      res.status(500).json({ message: "√âchec de la r√©cup√©ration de la conversation" });
    }
  });
  
  app.post("/api/messages", isAuthenticated, async (req, res) => {
    try {
      const validatedData = insertMessageSchema.parse(req.body);
      
      // V√©rifier que l'exp√©diteur est bien l'utilisateur connect√©
      if (validatedData.senderId !== req.user!.id) {
        return res.status(403).json({ message: "Vous ne pouvez pas envoyer des messages au nom d'un autre utilisateur" });
      }
      
      // V√©rifier que le destinataire existe
      const recipient = await storage.getUser(validatedData.recipientId);
      if (!recipient) {
        return res.status(404).json({ message: "Destinataire non trouv√©" });
      }
      
      const message = await storage.createMessage(validatedData);
      
      // Ajouter une entr√©e √† l'historique
      await storage.createHistory({
        userId: req.user!.id,
        operation: "create",
        entityType: "message",
        entityId: message.id,
        details: `Message envoy√© √† ${recipient.username}`
      });
      
      res.status(201).json(message);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Donn√©es de message invalides", errors: error.errors });
      }
      console.error("Erreur lors de la cr√©ation du message:", error);
      res.status(500).json({ message: "√âchec de la cr√©ation du message" });
    }
  });
  
  app.put("/api/messages/:id/read", isAuthenticated, async (req, res) => {
    try {
      const messageId = parseInt(req.params.id);
      if (isNaN(messageId)) {
        return res.status(400).json({ message: "ID de message invalide" });
      }
      
      const message = await storage.getMessage(messageId);
      if (!message) {
        return res.status(404).json({ message: "Message non trouv√©" });
      }
      
      // V√©rifier que l'utilisateur est bien le destinataire
      if (message.recipientId !== req.user!.id) {
        return res.status(403).json({ message: "Vous ne pouvez pas marquer comme lu un message dont vous n'√™tes pas le destinataire" });
      }
      
      const updatedMessage = await storage.markMessageAsRead(messageId);
      res.json(updatedMessage);
    } catch (error) {
      console.error("Erreur lors du marquage du message comme lu:", error);
      res.status(500).json({ message: "√âchec du marquage du message comme lu" });
    }
  });
  
  app.delete("/api/messages/:id", isAuthenticated, async (req, res) => {
    try {
      const messageId = parseInt(req.params.id);
      if (isNaN(messageId)) {
        return res.status(400).json({ message: "ID de message invalide" });
      }
      
      const message = await storage.getMessage(messageId);
      if (!message) {
        return res.status(404).json({ message: "Message non trouv√©" });
      }
      
      // V√©rifier les permissions utilisateur
      const userId = req.user!.id;
      const userRole = req.user!.role;
      const isSender = message.senderId === userId;
      const isRecipient = message.recipientId === userId;
      const isAgent = userRole === 'agent' || userRole === 'sub-agent';
      const isAdmin = userRole === 'admin';
      
      // Permission de suppression:
      // - Administrateurs peuvent supprimer tous les messages
      // - Agents peuvent supprimer tous les messages qu'ils ont re√ßus ou envoy√©s
      // - Chasseurs peuvent supprimer uniquement les messages dont ils sont exp√©diteurs ou destinataires
      if (!isAdmin && !isAgent && !isSender && !isRecipient) {
        return res.status(403).json({ 
          message: "Vous n'avez pas les droits pour supprimer ce message" 
        });
      }
      
      // Pour l'admin et les agents, on supprime directement le message
      if (isAdmin) {
        await storage.deleteMessage(messageId);
        
        // Enregistrer dans l'historique
        await storage.createHistory({
          userId: req.user!.id,
          operation: "delete",
          entityType: "message",
          entityId: messageId,
          details: `Suppression administrative d'un message`
        });
        
        return res.json({ message: "Message supprim√© d√©finitivement par l'administrateur" });
      } 
      else if (isAgent) {
        // Marquer comme supprim√© avec le flag correspondant
        if (isSender) {
          await storage.markMessageAsDeleted(messageId, true);
        } else {
          await storage.markMessageAsDeleted(messageId, false);
        }
        
        // Si les deux parties ont supprim√© le message, le supprimer d√©finitivement
        const updatedMessage = await storage.getMessage(messageId);
        if (updatedMessage && (updatedMessage.isDeletedBySender && updatedMessage.isDeleted)) {
          await storage.deleteMessage(messageId);
          return res.json({ message: "Message supprim√© d√©finitivement" });
        }
        
        return res.json({ message: "Message supprim√© avec succ√®s" });
      } 
      else {
        // Pour les chasseurs et autres r√¥les: comportement standard
        await storage.markMessageAsDeleted(messageId, isSender);
        
        // Si les deux parties ont supprim√© le message, le supprimer d√©finitivement
        if ((isSender && message.isDeleted) || (isRecipient && message.isDeletedBySender)) {
          await storage.deleteMessage(messageId);
        }
        
        return res.json({ message: "Message supprim√© avec succ√®s" });
      }
    } catch (error) {
      console.error("Erreur lors de la suppression du message:", error);
      res.status(500).json({ message: "√âchec de la suppression du message" });
    }
  });
  
  // Routes pour les messages group√©s
  app.get("/api/group-messages", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user!.id;
      
      // V√©rifier si la m√©thode getGroupMessagesByUser existe sur storage
      if (typeof storage.getGroupMessagesByUser !== 'function') {
        console.error("M√©thode getGroupMessagesByUser non impl√©ment√©e");
        return res.status(500).json({ message: "Fonctionnalit√© en cours d'impl√©mentation" });
      }
      
      const messages = await storage.getGroupMessagesByUser(userId);
      res.json(messages);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des messages de groupe:", error);
      res.status(500).json({ message: "√âchec de la r√©cup√©ration des messages de groupe" });
    }
  });
  
  app.get("/api/group-messages/:id", isAuthenticated, async (req, res) => {
    try {
      const messageId = parseInt(req.params.id);
      if (isNaN(messageId)) {
        return res.status(400).json({ message: "ID de message invalide" });
      }
      
      const message = await storage.getGroupMessageWithSender(messageId);
      if (!message) {
        return res.status(404).json({ message: "Message non trouv√©" });
      }
      
      // V√©rifier que l'utilisateur a acc√®s √† ce message de groupe
      const user = req.user!;
      if (message.targetRole !== user.role && message.senderId !== user.id) {
        return res.status(403).json({ message: "Vous n'avez pas acc√®s √† ce message" });
      }
      
      // Si le message est cibl√© par r√©gion, v√©rifier que l'utilisateur est dans cette r√©gion
      if (message.targetRegion && message.targetRegion !== user.region && message.senderId !== user.id) {
        return res.status(403).json({ message: "Ce message est destin√© √† une autre r√©gion" });
      }
      
      // Marquer le message comme lu par cet utilisateur
      await storage.markGroupMessageAsRead(messageId, user.id);
      
      res.json(message);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration du message de groupe:", error);
      res.status(500).json({ message: "√âchec de la r√©cup√©ration du message de groupe" });
    }
  });
  
  app.post("/api/group-messages", isAuthenticated, async (req, res) => {
    try {
      const validatedData = insertGroupMessageSchema.parse(req.body);
      
      // V√©rifier que l'exp√©diteur est bien l'utilisateur connect√©
      if (validatedData.senderId !== req.user!.id) {
        return res.status(403).json({ message: "Vous ne pouvez pas envoyer des messages au nom d'un autre utilisateur" });
      }
      
      // V√©rifier que l'utilisateur a les droits pour envoyer des messages de groupe
      const userRole = req.user!.role;
      if (userRole !== 'admin' && userRole !== 'agent') {
        return res.status(403).json({ message: "Seuls les administrateurs et les agents peuvent envoyer des messages de groupe" });
      }
      
      const message = await storage.createGroupMessage(validatedData);
      
      // Ajouter une entr√©e √† l'historique
      await storage.createHistory({
        userId: req.user!.id,
        operation: "create",
        entityType: "group_message",
        entityId: message.id,
        details: `Message de groupe envoy√© aux ${validatedData.targetRole}s${validatedData.targetRegion ? ' de la r√©gion ' + validatedData.targetRegion : ''}`
      });
      
      res.status(201).json(message);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Donn√©es de message invalides", errors: error.errors });
      }
      console.error("Erreur lors de la cr√©ation du message de groupe:", error);
      res.status(500).json({ message: "√âchec de la cr√©ation du message de groupe" });
    }
  });
  
  app.put("/api/group-messages/:id/read", isAuthenticated, async (req, res) => {
    try {
      const messageId = parseInt(req.params.id);
      if (isNaN(messageId)) {
        return res.status(400).json({ message: "ID de message invalide" });
      }
      
      const userId = req.user!.id;
      const result = await storage.markGroupMessageAsRead(messageId, userId);
      
      res.json({ message: "Message marqu√© comme lu", data: result });
    } catch (error) {
      console.error("Erreur lors du marquage du message de groupe comme lu:", error);
      res.status(500).json({ message: "√âchec du marquage du message de groupe comme lu" });
    }
  });
  
  app.delete("/api/group-messages/:id", isAuthenticated, async (req, res) => {
    try {
      const messageId = parseInt(req.params.id);
      if (isNaN(messageId)) {
        return res.status(400).json({ message: "ID de message invalide" });
      }
      
      const message = await storage.getGroupMessage(messageId);
      if (!message) {
        return res.status(404).json({ message: "Message non trouv√©" });
      }
      
      const userId = req.user!.id;
      const userRole = req.user!.role;
      const isAdmin = userRole === 'admin';
      const isAgent = userRole === 'agent' || userRole === 'sub-agent';
      const isSender = message.senderId === userId;
      
      // L'administrateur peut supprimer compl√®tement n'importe quel message
      if (isAdmin) {
        // Supprimer d√©finitivement le message et toutes les r√©f√©rences de lecture
        // Note: Cela n√©cessite une fonction dans storage pour supprimer compl√®tement
        try {
          await db.delete(groupMessageReads).where(eq(groupMessageReads.messageId, messageId));
          await db.delete(groupMessages).where(eq(groupMessages.id, messageId));
          
          // Enregistrer dans l'historique
          await storage.createHistory({
            userId: userId,
            operation: "delete",
            entityType: "group_message",
            entityId: messageId,
            details: `Suppression administrative d'un message de groupe`
          });
          
          return res.json({ message: "Message de groupe supprim√© d√©finitivement par l'administrateur" });
        } catch (err) {
          console.error("Erreur lors de la suppression d√©finitive du message:", err);
          return res.status(500).json({ message: "√âchec de la suppression d√©finitive du message" });
        }
      }
      
      // Les agents peuvent aussi supprimer les messages (qu'ils soient exp√©diteurs ou non)
      if (isAgent) {
        if (isSender) {
          try {
            // L'agent qui a envoy√© le message peut le supprimer d√©finitivement
            await db.delete(groupMessageReads).where(eq(groupMessageReads.messageId, messageId));
            await db.delete(groupMessages).where(eq(groupMessages.id, messageId));
            
            await storage.createHistory({
              userId: userId,
              operation: "delete",
              entityType: "group_message",
              entityId: messageId,
              details: `Suppression d'un message de groupe par son exp√©diteur agent`
            });
            
            return res.json({ message: "Message de groupe supprim√© d√©finitivement" });
          } catch (err) {
            console.error("Erreur lors de la suppression du message par l'agent:", err);
            return res.status(500).json({ message: "√âchec de la suppression du message" });
          }
        } else {
          // Pour l'agent qui n'est pas l'exp√©diteur, marquer comme supprim√© pour lui
          await storage.markGroupMessageAsDeleted(messageId, userId);
          return res.json({ message: "Message de groupe masqu√© pour vous" });
        }
      }
      
      // Pour les autres utilisateurs (chasseurs, etc.)
      // Marquer le message comme supprim√©/cach√© pour cet utilisateur
      await storage.markGroupMessageAsDeleted(messageId, userId);
      return res.json({ message: "Message de groupe masqu√© pour vous" });
    } catch (error) {
      console.error("Erreur lors de la suppression du message de groupe:", error);
      res.status(500).json({ message: "√âchec de la suppression du message de groupe" });
    }
  });

  // Settings API routes - Campagne de chasse
  app.get("/api/settings/campaign", async (req, res) => {
    try {
      // Renvoyer les param√®tres par d√©faut pour la campagne de chasse actuelle
      const currentYear = new Date().getFullYear();
      res.json({
        year: currentYear,
        region: "SN",
        startDate: `${currentYear}-11-15`,
        endDate: `${currentYear + 1}-04-30`,
        waterGameStartDate: `${currentYear}-11-15`,
        waterGameEndDate: `${currentYear + 1}-04-30`,
      });
    } catch (error) {
      console.error("Error retrieving campaign settings:", error);
      res.status(500).json({ message: "Failed to retrieve campaign settings" });
    }
  });
  
  // Route alternative - Utilis√©e par la page PermitRequest
  app.get("/api/settings/hunting-campaign", async (req, res) => {
    try {
      // R√©cup√©rer les param√®tres de la campagne de chasse depuis la base de donn√©es
      const campaignSettings = await storage.getHuntingCampaignSettings();
      const today = new Date();
      
      // Si des param√®tres existent, les utiliser
      if (campaignSettings) {
        const startDate = new Date(campaignSettings.startDate);
        const endDate = new Date(campaignSettings.endDate);
        
        // D√©terminer si la campagne est active en fonction de la date actuelle
        const isActive = today >= startDate && today <= endDate;
        
        // Renvoyer les param√®tres avec l'√©tat d'activation calcul√©
        return res.json({
          ...campaignSettings,
          name: `Campagne de Chasse ${campaignSettings.year}`,
          isActive: isActive
        });
      }
      
      // Si aucun param√®tre n'existe, cr√©er des valeurs par d√©faut
      const currentYear = new Date().getFullYear();
      const defaultStartDate = new Date(`${currentYear}-11-15`);
      const defaultEndDate = new Date(`${currentYear + 1}-04-30`);
      const isActive = today >= defaultStartDate && today <= defaultEndDate;
      
      const defaultCampaignData = {
        year: currentYear.toString(),
        name: `Campagne de Chasse ${currentYear}-${currentYear + 1}`,
        region: "SN",
        startDate: defaultStartDate.toISOString(),
        endDate: defaultEndDate.toISOString(),
        waterGameStartDate: defaultStartDate.toISOString(),
        waterGameEndDate: defaultEndDate.toISOString(),
        isActive: isActive
      };
      
      res.json(defaultCampaignData);
    } catch (error) {
      console.error("Error retrieving hunting campaign settings:", error);
      res.status(500).json({ message: "Failed to retrieve hunting campaign settings" });
    }
  });
  
  // Endpoint pour mettre √† jour les param√®tres de la campagne de chasse
  app.post("/api/settings/hunting-campaign", async (req, res) => {
    try {
      // V√©rifier que l'utilisateur est un administrateur
      if (req.user?.role !== "admin") {
        return res.status(403).json({ message: "Acc√®s non autoris√©, seul un administrateur peut modifier les param√®tres de la campagne" });
      }
      
      const campaignData = req.body;
      
      // Validation de base des donn√©es re√ßues
      if (!campaignData.startDate || !campaignData.endDate) {
        return res.status(400).json({ 
          message: "Les dates de d√©but et de fin sont obligatoires" 
        });
      }
      
      // Convertir les dates en objets Date pour validation
      const startDate = new Date(campaignData.startDate);
      const endDate = new Date(campaignData.endDate);
      
      // V√©rifier que la date de fin est apr√®s la date de d√©but
      if (endDate <= startDate) {
        return res.status(400).json({ 
          message: "La date de fin doit √™tre post√©rieure √† la date de d√©but" 
        });
      }
      
      // Dans une version future, ce code sauvegardera les donn√©es dans une base de donn√©es
      // Pour l'instant, nous allons simplement enregistrer les donn√©es dans les logs et retourner une r√©ponse
      console.log("Param√®tres de la campagne cyn√©g√©tique mis √† jour:", campaignData);

      // Ajouter une entr√©e dans l'historique
      if (req.user?.id) {
        await storage.createHistory({
          userId: req.user.id,
          operation: "update",
          entityType: "hunting_campaign_settings",
          entityId: 0,
          details: `Mise √† jour des param√®tres de la campagne cyn√©g√©tique: du ${new Date(campaignData.startDate).toLocaleDateString()} au ${new Date(campaignData.endDate).toLocaleDateString()}`
        });
      }
      
      res.json({
        message: "Param√®tres de la campagne cyn√©g√©tique sauvegard√©s avec succ√®s",
        data: {
          ...campaignData,
          // Assurer que les dates sont au format ISO
          startDate: new Date(campaignData.startDate).toISOString(),
          endDate: new Date(campaignData.endDate).toISOString()
        }
      });
    } catch (error) {
      console.error("Error saving hunting campaign settings:", error);
      res.status(500).json({ message: "Failed to save hunting campaign settings" });
    }
  });
  
  // Settings API routes - Tarifs des permis
  app.get("/api/settings/permit-fees", async (req, res) => {
    try {
      // Renvoyer les tarifs par d√©faut des permis
      res.json({
        sportifPetiteChasseResident: 15000,
        sportifPetiteChasseTourriste1Week: 15000,
        sportifPetiteChasseTourriste2Weeks: 25000,
        sportifPetiteChasseTourriste1Month: 45000,
        coutumierPetiteChasse: 3000,
        grandeChaseResident: 45000,
        grandeChasseTourriste1Week: 30000,
        grandeChasseTourriste2Weeks: 50000,
        grandeChasseTourriste1Month: 90000,
        specialGibierEauResident: 30000,
        specialGibierEauTourriste1Week: 15000,
        specialGibierEauTourriste1Month: 45000
      });
    } catch (error) {
      console.error("Error retrieving permit fees settings:", error);
      res.status(500).json({ message: "Failed to retrieve permit fees settings" });
    }
  });

  // Hunting Guide API Routes
  app.get("/api/guides", isAuthenticated, async (req, res) => {
    try {
      // L'acc√®s est autoris√© pour les administrateurs, les agents et les agents secteur
      if (req.user?.role !== "admin" && req.user?.role !== "agent" && req.user?.role !== "sub-agent") {
        return res.status(403).json({ message: "Acc√®s non autoris√©" });
      }

      // Les administrateurs ont acc√®s √† tous les guides
      if (req.user.role === "admin") {
        const guides = await storage.getAllHuntingGuides();
        return res.json(guides);
      }
      
      // Pour les agents r√©gionaux, filtrer par r√©gion
      if (req.user.role === "agent") {
        if (!req.user.region) {
          return res.status(400).json({ message: "R√©gion non d√©finie pour cet agent" });
        }
        
        // R√©cup√©rer les guides de la r√©gion sp√©cifique
        const guides = await storage.getHuntingGuidesByRegion(req.user.region);
        return res.json(guides);
      }
      
      // Pour les agents secteur, filtrer par zone (d√©partement)
      if (req.user.role === "sub-agent") {
        // R√©cup√©rer la zone (d√©partement) de l'utilisateur depuis la requ√™te ou l'utilisateur
        const zone = req.query.zone as string || req.user.zone;
        
        if (!zone) {
          return res.status(400).json({ message: "Zone non d√©finie pour cet agent secteur" });
        }
        
        // R√©cup√©rer les guides de la zone sp√©cifique
        const guides = await storage.getHuntingGuidesByZone(zone);
        return res.json(guides);
      }
      
      // Si on arrive ici, c'est une erreur
      res.status(500).json({ message: "Une erreur est survenue lors de la r√©cup√©ration des guides" });
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des guides de chasse:", error);
      res.status(500).json({ message: "Erreur lors de la r√©cup√©ration des guides de chasse" });
    }
  });

  // Endpoint sp√©cifique pour r√©cup√©rer les guides de chasse d'une zone particuli√®re
  app.get("/api/hunting-guides/zone/:zone", isAuthenticated, async (req, res) => {
    try {
      // V√©rifier que l'utilisateur est un agent secteur ou admin ou agent
      if (req.user?.role !== "admin" && req.user?.role !== "agent" && req.user?.role !== "sub-agent") {
        return res.status(403).json({ message: "Acc√®s non autoris√©" });
      }

      const zone = req.params.zone;
      if (!zone) {
        return res.status(400).json({ message: "Zone non sp√©cifi√©e" });
      }
      
      // Si c'est un agent secteur, v√©rifier que la zone correspond √† sa zone
      if (req.user.role === "sub-agent" && req.user.zone && req.user.zone !== zone) {
        return res.status(403).json({ message: "Vous n'avez pas acc√®s aux guides de cette zone" });
      }
      
      const guides = await storage.getHuntingGuidesByZone(zone);
      res.json(guides);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des guides de chasse par zone:", error);
      res.status(500).json({ message: "Erreur lors de la r√©cup√©ration des guides de chasse par zone" });
    }
  });
  
  // Route pour r√©cup√©rer les informations du guide connect√©
  app.get("/api/guides/me", isAuthenticated, async (req, res) => {
    try {
      // V√©rifier que l'utilisateur est un guide de chasse
      if (req.user?.role !== "hunting-guide") {
        return res.status(403).json({ message: "Acc√®s limit√© aux guides de chasse" });
      }
      
      // R√©cup√©rer le guide associ√© √† l'ID utilisateur connect√©
      const guides = await storage.getAllHuntingGuides();
      const guide = guides.find(g => g.userId === req.user?.id);
      
      if (!guide) {
        return res.status(404).json({ message: "Guide de chasse non trouv√© pour cet utilisateur" });
      }
      
      res.json(guide);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration du guide de chasse:", error);
      res.status(500).json({ message: "Erreur lors de la r√©cup√©ration du guide de chasse" });
    }
  });
  
  // Route pour r√©cup√©rer tous les chasseurs (pour l'association)
  app.get("/api/hunters/all", isAuthenticated, async (req, res) => {
    try {
      // V√©rifier que l'utilisateur est un guide de chasse, un admin ou un agent
      if (req.user?.role !== "hunting-guide" && req.user?.role !== "admin" && req.user?.role !== "agent") {
        return res.status(403).json({ message: "Acc√®s non autoris√©" });
      }
      
      const hunters = await storage.getAllHunters();
      res.json(hunters);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des chasseurs:", error);
      res.status(500).json({ message: "Erreur lors de la r√©cup√©ration des chasseurs" });
    }
  });
  
  // Route pour r√©cup√©rer les chasseurs associ√©s √† un guide
  app.get("/api/guides/hunters", isAuthenticated, async (req, res) => {
    try {
      // V√©rifier que l'utilisateur est un guide de chasse
      if (req.user?.role !== "hunting-guide") {
        return res.status(403).json({ message: "Acc√®s limit√© aux guides de chasse" });
      }
      
      // R√©cup√©rer le guide associ√© √† l'ID utilisateur connect√©
      const guides = await storage.getAllHuntingGuides();
      const guide = guides.find(g => g.userId === req.user?.id);
      
      if (!guide) {
        return res.status(404).json({ message: "Guide de chasse non trouv√© pour cet utilisateur" });
      }
      
      const associations = await storage.getGuideHunterAssociationsWithHunters(guide.id);
      res.json(associations);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des chasseurs associ√©s:", error);
      res.status(500).json({ message: "Erreur lors de la r√©cup√©ration des chasseurs associ√©s" });
    }
  });
  
  // Route pour associer des chasseurs √† un guide
  app.post("/api/guides/associate-hunters", isAuthenticated, async (req, res) => {
    try {
      // V√©rifier que l'utilisateur est un guide de chasse
      if (req.user?.role !== "hunting-guide") {
        return res.status(403).json({ message: "Acc√®s limit√© aux guides de chasse" });
      }
      
      // Extraire l'ID des chasseurs du corps de la requ√™te
      const { hunterIds } = req.body;
      
      if (!hunterIds || !Array.isArray(hunterIds) || hunterIds.length === 0) {
        return res.status(400).json({ message: "IDs des chasseurs manquants ou invalides" });
      }
      
      // R√©cup√©rer le guide associ√© √† l'ID utilisateur connect√©
      const guides = await storage.getAllHuntingGuides();
      const guide = guides.find(g => g.userId === req.user?.id);
      
      if (!guide) {
        return res.status(404).json({ message: "Guide de chasse non trouv√© pour cet utilisateur" });
      }
      
      // Associer chaque chasseur au guide
      const results = [];
      for (const hunterId of hunterIds) {
        try {
          const association = await storage.associateHunterToGuide(guide.id, hunterId);
          results.push(association);
        } catch (err) {
          console.error(`Erreur lors de l'association du chasseur ${hunterId}:`, err);
          // Continuer avec les autres chasseurs
        }
      }
      
      // Enregistrer dans l'historique
      await storage.createHistory({
        userId: req.user.id,
        operation: "associate",
        entityType: "guide-hunters",
        entityId: guide.id,
        details: `Association de ${results.length} chasseur(s) au guide ${guide.firstName} ${guide.lastName}`
      });
      
      res.status(200).json({ 
        message: `${results.length} chasseur(s) associ√©(s) avec succ√®s`,
        associations: results 
      });
    } catch (error) {
      console.error("Erreur lors de l'association des chasseurs:", error);
      res.status(500).json({ message: "Erreur lors de l'association des chasseurs" });
    }
  });
  
  // Route pour dissocier un chasseur d'un guide
  app.delete("/api/guides/remove-hunter/:hunterId", isAuthenticated, async (req, res) => {
    try {
      // V√©rifier que l'utilisateur est un guide de chasse
      if (req.user?.role !== "hunting-guide") {
        return res.status(403).json({ message: "Acc√®s limit√© aux guides de chasse" });
      }
      
      const hunterId = parseInt(req.params.hunterId);
      
      if (isNaN(hunterId)) {
        return res.status(400).json({ message: "ID du chasseur invalide" });
      }
      
      // R√©cup√©rer le guide associ√© √† l'ID utilisateur connect√©
      const guides = await storage.getAllHuntingGuides();
      const guide = guides.find(g => g.userId === req.user?.id);
      
      if (!guide) {
        return res.status(404).json({ message: "Guide de chasse non trouv√© pour cet utilisateur" });
      }
      
      // V√©rifier que le chasseur est bien associ√© √† ce guide
      const associations = await storage.getGuideHunterAssociations(guide.id);
      const isAssociated = associations.some(a => a.hunterId === hunterId);
      
      if (!isAssociated) {
        return res.status(404).json({ message: "Ce chasseur n'est pas associ√© √† ce guide" });
      }
      
      // Dissocier le chasseur
      const success = await storage.removeHunterAssociation(guide.id, hunterId);
      
      if (!success) {
        return res.status(500).json({ message: "√âchec de la dissociation du chasseur" });
      }
      
      // R√©cup√©rer les informations du chasseur pour l'historique
      const hunter = await storage.getHunter(hunterId);
      
      // Enregistrer dans l'historique
      await storage.createHistory({
        userId: req.user.id,
        operation: "remove-association",
        entityType: "guide-hunter",
        entityId: guide.id,
        details: `Dissociation du chasseur ${hunter?.firstName} ${hunter?.lastName} (ID: ${hunterId}) du guide ${guide.firstName} ${guide.lastName}`
      });
      
      res.status(200).json({ 
        message: "Chasseur dissoci√© avec succ√®s" 
      });
    } catch (error) {
      console.error("Erreur lors de la dissociation du chasseur:", error);
      res.status(500).json({ message: "Erreur lors de la dissociation du chasseur" });
    }
  });

  app.get("/api/guides/:id", isAuthenticated, async (req, res) => {
    try {
      // L'acc√®s est autoris√© pour les administrateurs, les agents et les agents secteur
      if (req.user?.role !== "admin" && req.user?.role !== "agent" && req.user?.role !== "sub-agent") {
        return res.status(403).json({ message: "Acc√®s non autoris√©" });
      }

      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "ID de guide invalide" });
      }
      
      const guide = await storage.getHuntingGuide(id);
      if (!guide) {
        return res.status(404).json({ message: "Guide de chasse non trouv√©" });
      }
      
      // Si c'est un agent ou un agent secteur, v√©rifier que le guide est dans sa r√©gion
      if (req.user.role === "agent" || req.user.role === "sub-agent") {
        if (!req.user.region || guide.region !== req.user.region) {
          return res.status(403).json({ message: "Vous n'avez pas acc√®s √† ce guide qui n'est pas dans votre r√©gion" });
        }
      }
      
      res.json(guide);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration du guide de chasse:", error);
      res.status(500).json({ message: "Erreur lors de la r√©cup√©ration du guide de chasse" });
    }
  });

  app.post("/api/guides", isAuthenticated, async (req, res) => {
    try {
      // V√©rifier que l'utilisateur est un administrateur
      if (req.user?.role !== "admin") {
        return res.status(403).json({ message: "Acc√®s non autoris√©" });
      }

      // Valider les donn√©es
      const data = createHuntingGuideWithUserSchema.parse(req.body);
      
      // V√©rifier si un guide avec le m√™me num√©ro d'identit√© existe d√©j√†
      const existingGuide = await storage.getHuntingGuideByIdNumber(data.idNumber);
      if (existingGuide) {
        return res.status(400).json({ message: "Un guide avec ce num√©ro d'identit√© existe d√©j√†" });
      }

      // V√©rifier si le nom d'utilisateur existe d√©j√†
      const existingUser = await storage.getUserByUsername(data.username);
      if (existingUser) {
        return res.status(400).json({ message: "Ce nom d'utilisateur est d√©j√† utilis√©" });
      }

      // 1. Cr√©er le compte utilisateur
      // Utiliser le r√¥le 'agent' au lieu de 'hunting-guide' qui n'existe pas dans l'enum PostgreSQL
      const user = await storage.createUser({
        username: data.username,
        password: data.password,
        email: data.email,
        role: "agent", // Remplac√© 'hunting-guide' par 'agent' pour √©viter l'erreur d'enum
        firstName: data.firstName,
        lastName: data.lastName,
        phone: data.phone,
        region: data.region
      });

      // 2. Cr√©er la fiche du guide de chasse
      const guide = await storage.createHuntingGuide({
        lastName: data.lastName,
        firstName: data.firstName,
        phone: data.phone,
        zone: data.zone,
        region: data.region,
        idNumber: data.idNumber,
        photo: data.photo,
        userId: user.id
      });

      // 3. Ajouter une entr√©e dans l'historique
      await storage.createHistory({
        userId: req.user?.id,
        operation: "create",
        entityType: "hunting_guide",
        entityId: guide.id,
        details: `Guide de chasse cr√©√©: ${guide.lastName} ${guide.firstName}`
      });

      res.status(201).json(guide);
    } catch (error) {
      console.error("Erreur lors de la cr√©ation du guide de chasse:", error);
      
      if (error instanceof z.ZodError) {
        return res.status(400).json({ 
          message: "Donn√©es invalides", 
          errors: error.errors 
        });
      }
      
      res.status(500).json({ message: "Erreur lors de la cr√©ation du guide de chasse" });
    }
  });

  app.patch("/api/guides/:id/status", isAuthenticated, async (req, res) => {
    try {
      // V√©rifier que l'utilisateur est un administrateur
      if (req.user?.role !== "admin") {
        return res.status(403).json({ message: "Acc√®s non autoris√©" });
      }

      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "ID de guide invalide" });
      }
      
      const { isActive } = req.body;
      if (typeof isActive !== 'boolean') {
        return res.status(400).json({ message: "Le statut doit √™tre un bool√©en" });
      }
      
      // Mettre √† jour le statut du guide
      const guide = await storage.updateHuntingGuide(id, { isActive });
      if (!guide) {
        return res.status(404).json({ message: "Guide de chasse non trouv√©" });
      }
      
      // Mettre √† jour le statut du compte utilisateur associ√©
      if (guide.userId) {
        await storage.updateUser(guide.userId, { isActive });
      }
      
      // Ajouter une entr√©e dans l'historique
      await storage.createHistory({
        userId: req.user?.id,
        operation: "update",
        entityType: "hunting_guide",
        entityId: id,
        details: `Statut du guide de chasse mis √† jour: ${guide.lastName} ${guide.firstName} (${isActive ? 'Activ√©' : 'D√©sactiv√©'})`
      });
      
      res.json(guide);
    } catch (error) {
      console.error("Erreur lors de la mise √† jour du statut du guide:", error);
      res.status(500).json({ message: "Erreur lors de la mise √† jour du statut du guide" });
    }
  });

  // Endpoint pour supprimer tous les guides de chasse (r√©serv√© aux administrateurs)
  app.delete("/api/guides/all", isAuthenticated, async (req, res) => {
    try {
      // V√©rifier que l'utilisateur est un administrateur
      if (req.user?.role !== "admin") {
        return res.status(403).json({ message: "Acc√®s non autoris√©" });
      }

      // Supprimer tous les guides de chasse
      const deletedCount = await storage.deleteAllHuntingGuides();
      
      // Ajouter une entr√©e dans l'historique
      await storage.createHistory({
        userId: req.user?.id,
        operation: "delete",
        entityType: "hunting_guide",
        entityId: 0, // 0 indique une op√©ration globale
        details: `Suppression de tous les guides de chasse (${deletedCount} guides supprim√©s)`
      });
      
      res.json({ message: `${deletedCount} guides de chasse ont √©t√© supprim√©s` });
    } catch (error) {
      console.error("Erreur lors de la suppression de tous les guides de chasse:", error);
      res.status(500).json({ message: "Erreur lors de la suppression de tous les guides de chasse" });
    }
  });

  // User API routes
  app.post("/api/users", async (req, res) => {
    try {
      // Validate user data
      const validatedData = insertUserSchema.parse(req.body);
      
      // Check if username already exists
      const existingUsername = await storage.getUserByUsername(validatedData.username);
      if (existingUsername) {
        return res.status(400).json({ message: "Ce nom d'utilisateur existe d√©j√†" });
      }
      
      // Check if email already exists
      const existingEmail = await storage.getUserByEmail(validatedData.email);
      if (existingEmail) {
        return res.status(400).json({ message: "Cet email est d√©j√† utilis√©" });
      }
      
      // Si c'est un compte de chasseur, il faut v√©rifier et associer le chasseur
      if (validatedData.role === 'hunter' && validatedData.hunterId) {
        // V√©rifier que le ID de chasseur existe
        const hunter = await storage.getHunter(validatedData.hunterId);
        if (!hunter) {
          return res.status(400).json({ message: "Chasseur non trouv√©" });
        }
        
        // V√©rifier si ce chasseur a d√©j√† un utilisateur associ√©
        const existingUsers = await storage.getAllUsers();
        const alreadyHasUser = existingUsers.some(u => u.hunterId === validatedData.hunterId);
        
        if (alreadyHasUser) {
          return res.status(400).json({ 
            message: "Ce chasseur a d√©j√† un compte utilisateur associ√©"
          });
        }
        
        console.log(`Cr√©ation d'un compte utilisateur pour le chasseur ID ${validatedData.hunterId}`);
      }
      
      // Create user
      const user = await storage.createUser(validatedData);
      console.log("Utilisateur cr√©√© avec succ√®s:", user);
      
      // Pr√©parer un message SMS pour le nouveau compte si c'est un chasseur
      if (validatedData.role === 'hunter' && user.hunterId) {
        try {
          const hunter = await storage.getHunter(user.hunterId);
          if (hunter && hunter.phone) {
            const smsMessage = `Bienvenue sur SIGPE! Votre compte de chasseur a √©t√© cr√©√© avec succ√®s. Nom d'utilisateur: ${user.username}, Mot de passe: ${validatedData.password}. Veuillez vous connecter et changer votre mot de passe.`;
            
            // Stocker le message dans l'historique pour l'envoi SMS
            await storage.createHistory({
              operation: "sms_notification",
              entityType: "user", 
              entityId: user.id,
              details: `SMS notification for hunter user: ${user.username} to phone ${hunter.phone}: ${smsMessage}`
            });
            
            console.log(`SMS notification prepared for new hunter user ${user.username} (ID: ${user.id}) to phone ${hunter.phone}`);
          }
        } catch (smsError) {
          console.error("Erreur lors de la pr√©paration de la notification SMS:", smsError);
        }
      }
      
      // Add history record
      await storage.createHistory({
        operation: "create",
        entityType: "user",
        entityId: user.id,
        details: `Utilisateur cr√©√©: ${user.username} avec le r√¥le ${user.role}`,
      });
      
      // Remove password from response
      const { password, ...userWithoutPassword } = user;
      
      res.status(201).json(userWithoutPassword);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Donn√©es utilisateur invalides", errors: error.errors });
      }
      console.error("Error creating user:", error);
      res.status(500).json({ message: "√âchec de la cr√©ation de l'utilisateur" });
    }
  });
  
  app.get("/api/users", async (req, res) => {
    try {
      const users = await storage.getAllUsers();
      
      // Remove passwords from response
      const usersWithoutPasswords = users.map(user => {
        const { password, ...userWithoutPassword } = user;
        return userWithoutPassword;
      });
      
      res.json(usersWithoutPasswords);
    } catch (error) {
      res.status(500).json({ message: "√âchec de la r√©cup√©ration des utilisateurs" });
    }
  });
  
  app.get("/api/users/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const user = await storage.getUser(id);
      
      if (!user) {
        return res.status(404).json({ message: "Utilisateur non trouv√©" });
      }
      
      // Remove password from response
      const { password, ...userWithoutPassword } = user;
      
      res.json(userWithoutPassword);
    } catch (error) {
      res.status(500).json({ message: "√âchec de la r√©cup√©ration de l'utilisateur" });
    }
  });
  
  // Route pour supprimer un utilisateur (admin uniquement)
  app.delete("/api/users/:id", isAuthenticated, async (req, res) => {
    try {
      console.log("üìù D√©but de la route de suppression d'utilisateur");
  
      // V√©rifier que l'utilisateur est un admin
      if (req.user?.role !== "admin") {
        console.error(`‚ùå Acc√®s refus√© pour l'utilisateur ${req.user?.username} avec le r√¥le ${req.user?.role}`);
        return res.status(403).json({ message: "Acc√®s refus√©. Seuls les administrateurs peuvent supprimer des utilisateurs." });
      }
      
      const userId = parseInt(req.params.id);
      if (isNaN(userId)) {
        console.error("‚ùå ID utilisateur invalide:", req.params.id);
        return res.status(400).json({ message: "ID utilisateur invalide" });
      }
      
      console.log(`üîç Tentative de suppression de l'utilisateur avec ID: ${userId}`);
      console.log(`üë§ Utilisateur demandant la suppression: ${req.user?.username} (${req.user?.role})`);
      
      // V√©rifier si le param√®tre force est pr√©sent
      const forceDelete = req.query.force === 'true';
      console.log(`üëâ Force delete param√®tre: ${forceDelete}`);
  
      // Obtenir l'utilisateur pour v√©rifier qu'il existe
      const user = await storage.getUser(userId);
      if (!user) {
        console.error(`‚ùå Utilisateur avec ID ${userId} non trouv√©`);
        return res.status(404).json({ message: "Utilisateur non trouv√©" });
      }
      
      console.log(`‚úÖ Utilisateur trouv√©: ${user.username} (${user.role})`);
      
      // Ne pas autoriser la suppression d'un administrateur
      if (user.role === "admin") {
        console.error(`‚ùå Tentative de suppression d'un administrateur (${user.username})`);
        return res.status(403).json({ message: "Impossible de supprimer un administrateur" });
      }
      
      // V√©rifier s'il s'agit d'un utilisateur avec des entit√©s associ√©es (hunter)
      if (user.role === "hunter" && user.hunterId) {
        console.log(`üëâ L'utilisateur est associ√© √† un chasseur (ID: ${user.hunterId})`);
        
        try {
          // Si force=true, supprimer le chasseur d'abord
          if (forceDelete) {
            console.log(`üëâ Tentative de suppression forc√©e du chasseur associ√© (ID: ${user.hunterId})`);
            const hunterDeleted = await storage.deleteHunter(user.hunterId, true);
            
            if (!hunterDeleted) {
              console.error(`‚ùå √âchec de la suppression du chasseur associ√©`);
              return res.status(500).json({ 
                message: "√âchec de la suppression du chasseur associ√© √† cet utilisateur"
              });
            }
            
            console.log(`‚úÖ Chasseur associ√© supprim√© avec succ√®s`);
          }
        } catch (error) {
          console.error(`‚ùå Erreur lors de la suppression du chasseur associ√©:`, error);
          return res.status(500).json({ 
            message: "Erreur lors de la suppression du chasseur associ√© √† cet utilisateur"
          });
        }
      }
      
      // Supprimer l'utilisateur
      console.log(`üóëÔ∏è Appel de la m√©thode deleteUser pour l'ID ${userId}`);
      const deleted = await storage.deleteUser(userId);
      
      if (!deleted) {
        console.error(`‚ùå La m√©thode deleteUser a retourn√© false pour l'ID ${userId}`);
        return res.status(500).json({ message: "√âchec de la suppression de l'utilisateur" });
      }
      
      console.log(`‚úÖ Suppression r√©ussie de l'utilisateur ${userId}`);
      
      // Cr√©er une entr√©e dans l'historique
      try {
        console.log(`üìù Ajout d'une entr√©e d'historique pour la suppression de l'utilisateur ${userId}`);
        await storage.createHistory({
          userId: req.user?.id,
          entityId: userId,
          entityType: "user",
          operation: "delete",
          details: `Utilisateur supprim√©: ${user.username}`
        });
        console.log(`‚úÖ Entr√©e d'historique cr√©√©e avec succ√®s`);
      } catch (historyError) {
        console.error(`‚ö†Ô∏è Erreur lors de la cr√©ation de l'entr√©e d'historique:`, historyError);
        // On continue malgr√© l'erreur d'historique
      }
      
      console.log(`üéâ Suppression de l'utilisateur ${userId} compl√©t√©e avec succ√®s`);
      res.status(200).json({ message: "Utilisateur supprim√© avec succ√®s" });
    } catch (error) {
      console.error("‚ùå Erreur lors de la suppression de l'utilisateur:", error);
      
      // Log plus d√©taill√© de l'erreur
      if (error instanceof Error) {
        console.error("Type d'erreur:", error.name);
        console.error("Message d'erreur:", error.message);
        console.error("Stack trace:", error.stack);
      }
      
      res.status(500).json({ 
        message: "Erreur serveur lors de la suppression de l'utilisateur",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });

  // Route pour r√©initialiser le mot de passe d'un utilisateur (admin uniquement)
  app.post("/api/users/:id/reset-password", isAuthenticated, async (req, res) => {
    // V√©rifier que l'utilisateur est un admin
    if (req.user?.role !== "admin") {
      return res.status(403).json({ message: "Acc√®s refus√©. Seuls les administrateurs peuvent r√©initialiser les mots de passe." });
    }
    
    const userId = parseInt(req.params.id);
    if (isNaN(userId)) {
      return res.status(400).json({ message: "ID utilisateur invalide" });
    }

    try {
      // Obtenir l'utilisateur pour v√©rifier qu'il existe
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "Utilisateur non trouv√©" });
      }
      
      // Ne pas autoriser la r√©initialisation du mot de passe d'un administrateur
      if (user.role === "admin" && user.id !== req.user.id) {
        return res.status(403).json({ message: "Impossible de r√©initialiser le mot de passe d'un autre administrateur" });
      }
      
      // G√©n√©rer un mot de passe temporaire
      const defaultPassword = "Password123!"; // Mot de passe temporaire
      
      // Mettre √† jour l'utilisateur avec le nouveau mot de passe
      const updatedUser = await storage.updateUser(userId, {
        password: defaultPassword
      });
      
      if (!updatedUser) {
        return res.status(500).json({ message: "√âchec de la r√©initialisation du mot de passe" });
      }
      
      // Cr√©er une entr√©e dans l'historique
      await storage.createHistory({
        userId: req.user?.id,
        entityId: userId,
        entityType: "user",
        operation: "reset_password",
        details: `Mot de passe r√©initialis√© pour l'utilisateur ${user.username}`
      });
      
      res.status(200).json({ message: "Mot de passe r√©initialis√© avec succ√®s", defaultPassword });
    } catch (error) {
      console.error("Erreur lors de la r√©initialisation du mot de passe:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // API pour g√©n√©rer un num√©ro de permis
  app.get("/api/permits/generate-number/:hunterId", async (req, res) => {
    try {
      const hunterId = parseInt(req.params.hunterId);
      if (isNaN(hunterId)) {
        return res.status(400).json({ message: "ID de chasseur invalide" });
      }

      // V√©rifier si le chasseur existe
      const hunter = await storage.getHunter(hunterId);
      if (!hunter) {
        return res.status(404).json({ message: "Chasseur non trouv√©" });
      }

      // Obtenir tous les permis pour d√©terminer le dernier num√©ro de s√©quence global
      const allPermits = await storage.getAllPermits();
      
      // G√©n√©rer le num√©ro de permis
      const currentYear = new Date().getFullYear();
      const regionPrefix = "SN"; // Code par d√©faut pour le S√©n√©gal
      
      // Trouver le dernier num√©ro de s√©quence (global, pas seulement pour ce chasseur)
      const lastSeq = allPermits.length > 0 
        ? Math.max(...allPermits.map(p => {
            const parts = p.permitNumber.split('-');
            return parts.length > 2 ? parseInt(parts[2]) || 0 : 0;
          }))
        : 0;
      
      const nextSeq = (lastSeq + 1).toString().padStart(3, '0');
      const permitNumber = `P-${regionPrefix}-${currentYear}-${nextSeq}-${hunterId}`;
      
      res.json({ permitNumber, hunterCategory: hunter.category });
    } catch (error) {
      console.error("Error generating permit number:", error);
      res.status(500).json({ message: "√âchec de la g√©n√©ration du num√©ro de permis" });
    }
  });
  
  // API pour r√©cup√©rer les agents
  app.get("/api/users/agents", isAuthenticated, async (req, res) => {
    try {
      // V√©rifier que l'utilisateur est un admin
      if (req.user?.role !== "admin") {
        return res.status(403).json({ 
          message: "Acc√®s refus√©. Seul l'administrateur peut r√©cup√©rer la liste des agents." 
        });
      }
      
      // R√©cup√©rer tous les agents
      const agents = await storage.getUsersByRole("agent");
      
      // Ajouter les sous-agents (sub-agent) aussi
      const subAgents = await storage.getUsersByRole("sub-agent");
      
      // Combiner les deux tableaux
      const allAgents = [...agents, ...subAgents];
      
      res.json(allAgents);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des agents:", error);
      res.status(500).json({ message: "√âchec de la r√©cup√©ration des agents" });
    }
  });

  // API pour mettre √† jour les informations d'un utilisateur (agent ou admin)
  app.patch("/api/users/:id", isAuthenticated, async (req, res) => {
    try {
      const userId = parseInt(req.params.id);
      
      if (isNaN(userId)) {
        return res.status(400).json({ message: "ID d'utilisateur invalide" });
      }
      
      // V√©rifier que l'utilisateur met √† jour son propre profil ou est un administrateur
      if (userId !== req.user?.id && req.user?.role !== "admin") {
        return res.status(403).json({ 
          message: "Acc√®s refus√©. Vous ne pouvez mettre √† jour que votre propre profil ou √™tre administrateur."
        });
      }
      
      // R√©cup√©rer l'utilisateur actuel
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "Utilisateur non trouv√©" });
      }
      
      // Pr√©parer les donn√©es √† mettre √† jour
      const { 
        firstName, lastName, phone, matricule, serviceLocation, 
        assignmentPost, region, email
      } = req.body;
      
      const updateData: any = {};
      
      // N'ajouter que les champs fournis
      if (firstName !== undefined) updateData.firstName = firstName;
      if (lastName !== undefined) updateData.lastName = lastName;
      if (phone !== undefined) updateData.phone = phone;
      if (matricule !== undefined) updateData.matricule = matricule;
      if (serviceLocation !== undefined) updateData.serviceLocation = serviceLocation;
      if (assignmentPost !== undefined) updateData.assignmentPost = assignmentPost;
      if (region !== undefined) updateData.region = region;
      if (email !== undefined) updateData.email = email;
      
      // Seuls les administrateurs peuvent mettre √† jour certains champs pour d'autres utilisateurs
      if (userId !== req.user?.id && req.user?.role !== "admin") {
        delete updateData.matricule;
        delete updateData.serviceLocation;
        delete updateData.assignmentPost;
        delete updateData.region;
      }
      
      // Mettre √† jour l'utilisateur
      const updatedUser = await storage.updateUser(userId, updateData);
      
      if (!updatedUser) {
        return res.status(500).json({ message: "√âchec de la mise √† jour du profil" });
      }
      
      // Enregistrer dans l'historique
      await storage.createHistory({
        userId: req.user?.id,
        operation: "update",
        entityType: "user",
        entityId: userId,
        details: `Mise √† jour du profil ${user.role}: ${user.username}`
      });
      
      res.status(200).json(updatedUser);
    } catch (error) {
      console.error("Erreur lors de la mise √† jour du profil:", error);
      res.status(500).json({ message: "√âchec de la mise √† jour du profil" });
    }
  });

  // Route pour suspendre un compte utilisateur
  app.post("/api/users/:id/suspend", isAuthenticated, async (req, res) => {
    try {
      // V√©rifier les permissions (seul un admin peut suspendre un compte)
      if (req.user?.role !== "admin") {
        return res.status(403).json({ message: "Action non autoris√©e" });
      }

      const userId = parseInt(req.params.id);
      
      // V√©rifier que l'utilisateur existe
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "Utilisateur non trouv√©" });
      }
      
      // V√©rifier qu'on ne tente pas de suspendre un compte admin
      if (user.role === "admin") {
        return res.status(403).json({ message: "Impossible de suspendre un compte administrateur" });
      }
      
      // Suspendre l'utilisateur
      const updatedUser = await storage.updateUser(userId, { isSuspended: true });
      
      if (!updatedUser) {
        return res.status(500).json({ message: "√âchec de la suspension du compte" });
      }
      
      // Si c'est un chasseur, suspendre tous ses permis actifs
      if (user.role === "hunter" && user.hunterId) {
        try {
          // R√©cup√©rer tous les permis actifs du chasseur
          const activePermits = await storage.getActivePermitsByHunterId(user.hunterId);
          
          // Suspendre chaque permis
          for (const permit of activePermits) {
            await storage.suspendPermit(permit.id);
            
            // Enregistrer dans l'historique pour chaque permis suspendu
            await storage.createHistory({
              userId: req.user?.id,
              operation: "suspend",
              entityType: "permit",
              entityId: permit.id,
              details: `Permis ${permit.permitNumber} suspendu automatiquement suite √† la suspension du chasseur`
            });
          }
          
          console.log(`${activePermits.length} permis suspendus pour le chasseur ID: ${user.hunterId}`);
        } catch (permitError) {
          console.error("Erreur lors de la suspension des permis:", permitError);
          // Continuer malgr√© l'erreur pour au moins suspendre le compte utilisateur
        }
      }
      
      // Enregistrer dans l'historique
      await storage.createHistory({
        userId: req.user?.id,
        operation: "suspend",
        entityType: "user",
        entityId: userId,
        details: `Suspension du compte ${user.role}: ${user.username}`
      });
      
      res.status(200).json({ message: "Compte suspendu avec succ√®s", user: updatedUser });
    } catch (error) {
      console.error("Erreur lors de la suspension du compte:", error);
      res.status(500).json({ message: "√âchec de la suspension du compte" });
    }
  });
  
  // Route pour r√©activer un compte utilisateur
  app.post("/api/users/:id/reactivate", isAuthenticated, async (req, res) => {
    try {
      // V√©rifier les permissions (seul un admin peut r√©activer un compte)
      if (req.user?.role !== "admin") {
        return res.status(403).json({ message: "Action non autoris√©e" });
      }

      const userId = parseInt(req.params.id);
      
      // V√©rifier que l'utilisateur existe
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "Utilisateur non trouv√©" });
      }
      
      // R√©activer l'utilisateur
      const updatedUser = await storage.updateUser(userId, { isSuspended: false });
      
      if (!updatedUser) {
        return res.status(500).json({ message: "√âchec de la r√©activation du compte" });
      }
      
      // Enregistrer dans l'historique
      await storage.createHistory({
        userId: req.user?.id,
        operation: "update",
        entityType: "user",
        entityId: userId,
        details: `R√©activation du compte ${user.role}: ${user.username}`
      });
      
      res.status(200).json({ message: "Compte r√©activ√© avec succ√®s", user: updatedUser });
    } catch (error) {
      console.error("Erreur lors de la r√©activation du compte:", error);
      res.status(500).json({ message: "√âchec de la r√©activation du compte" });
    }
  });

  // Routes pour la gestion des permis suspendus
  app.get("/api/permits/suspended", isAuthenticated, async (req, res) => {
    try {
      // V√©rifier les permissions (seuls admin et agents peuvent voir les permis suspendus)
      if (req.user?.role !== "admin" && req.user?.role !== "agent" && req.user?.role !== "sub-agent") {
        return res.status(403).json({ message: "Acc√®s non autoris√©" });
      }

      // R√©cup√©rer tous les permis suspendus
      const suspendedPermits = await storage.getSuspendedPermits();
      res.json(suspendedPermits);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des permis suspendus:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  app.delete("/api/permits/:id", isAuthenticated, async (req, res) => {
    try {
      // V√©rifier les permissions (seul admin peut supprimer un permis)
      if (req.user?.role !== "admin") {
        return res.status(403).json({ message: "Acc√®s non autoris√©" });
      }

      const permitId = parseInt(req.params.id);
      if (isNaN(permitId)) {
        return res.status(400).json({ message: "ID de permis invalide" });
      }

      // V√©rifier que le permis existe
      const permit = await storage.getPermit(permitId);
      if (!permit) {
        return res.status(404).json({ message: "Permis non trouv√©" });
      }

      // Supprimer le permis
      const success = await storage.deletePermit(permitId);
      
      if (!success) {
        return res.status(400).json({ 
          message: "Impossible de supprimer ce permis. Il pourrait avoir des taxes associ√©es." 
        });
      }

      // Enregistrer dans l'historique
      await storage.createHistory({
        userId: req.user?.id,
        operation: "delete",
        entityType: "permit",
        entityId: permitId,
        details: `Suppression du permis ${permit.permitNumber}`
      });

      res.status(200).json({ message: "Permis supprim√© avec succ√®s" });
    } catch (error) {
      console.error("Erreur lors de la suppression du permis:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  app.delete("/api/permits/suspended/all", isAuthenticated, async (req, res) => {
    try {
      // V√©rifier les permissions (seul admin peut supprimer tous les permis suspendus)
      if (req.user?.role !== "admin") {
        return res.status(403).json({ message: "Acc√®s non autoris√©" });
      }

      // Supprimer tous les permis suspendus
      const deletedPermits = await storage.deleteAllSuspendedPermits();
      
      // Enregistrer dans l'historique
      await storage.createHistory({
        userId: req.user?.id,
        operation: "delete_multiple",
        entityType: "permit",
        entityId: 0,
        details: `Suppression de tous les permis suspendus (${deletedPermits.length} permis)`
      });

      res.status(200).json({ 
        message: `${deletedPermits.length} permis suspendus ont √©t√© supprim√©s avec succ√®s`
      });
    } catch (error) {
      console.error("Erreur lors de la suppression des permis suspendus:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  app.delete("/api/permits/batch", isAuthenticated, async (req, res) => {
    try {
      // V√©rifier les permissions (seul admin peut supprimer des permis par lot)
      if (req.user?.role !== "admin") {
        return res.status(403).json({ message: "Acc√®s non autoris√©" });
      }

      const { permitIds } = req.body;

      if (!Array.isArray(permitIds) || permitIds.length === 0) {
        return res.status(400).json({ message: "Liste d'IDs de permis invalide ou vide" });
      }

      // Supprimer les permis par lot
      const deletedPermits = await storage.deletePermitBatch(permitIds);
      
      // Enregistrer dans l'historique
      await storage.createHistory({
        userId: req.user?.id,
        operation: "delete_multiple",
        entityType: "permit",
        entityId: 0,
        details: `Suppression par lot de ${deletedPermits.length} permis`
      });

      res.status(200).json({ 
        message: `${deletedPermits.length} permis ont √©t√© supprim√©s avec succ√®s`
      });
    } catch (error) {
      console.error("Erreur lors de la suppression par lot des permis:", error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  });

  // Route pour servir la description du projet au format HTML (peut √™tre converti en PDF par le navigateur)
  app.get("/project-description", (req, res) => {
    const path = require('path');
    res.sendFile(path.resolve('./project-description.html'));
  });

  // Routes pour les guides de chasse
  app.post("/api/guides", async (req, res) => {
    try {
      console.log("Received hunting guide creation request:", req.body);
      
      // Valider les donn√©es avec le sch√©ma
      try {
        const validatedData = createHuntingGuideWithUserSchema.parse(req.body);
        
        // Cr√©er un nouvel utilisateur pour le guide
        const userData = {
          username: validatedData.username,
          password: validatedData.password,
          email: validatedData.email || 'guide@example.com',
          role: 'guide',
          firstName: validatedData.firstName,
          lastName: validatedData.lastName,
          phone: validatedData.phone,
          region: validatedData.region,
          serviceLocation: validatedData.zone,
          isActive: true,
          createdAt: new Date().toISOString()
        };
        
        // Cr√©er l'utilisateur
        const user = await storage.createUser(userData);
        
        // Cr√©er le guide de chasse
        const guideData = {
          userId: user.id,
          firstName: validatedData.firstName,
          lastName: validatedData.lastName,
          phone: validatedData.phone,
          zone: validatedData.zone,
          region: validatedData.region,
          idNumber: validatedData.idNumber,
          photo: validatedData.photo || null,
          status: 'active',
          createdAt: new Date().toISOString()
        };
        
        const guide = await db.insert(huntingGuides).values(guideData).returning();
        
        // Ajouter une entr√©e dans l'historique
        await storage.createHistory({
          userId: req.user?.id,
          operation: "create",
          entityType: "guide",
          entityId: guide[0].id,
          details: `Guide de chasse cr√©√©: ${guide[0].firstName} ${guide[0].lastName}`
        });
        
        res.status(201).json(guide[0]);
      } catch (validationError) {
        console.error("Guide validation error:", validationError);
        if (validationError instanceof z.ZodError) {
          return res.status(400).json({ 
            message: "Erreur de validation des donn√©es du guide", 
            errors: validationError.errors 
          });
        }
        throw validationError;
      }
    } catch (error) {
      console.error("Guide creation error:", error);
      res.status(500).json({ 
        message: "√âchec de la cr√©ation du guide de chasse",
        error: error instanceof Error ? error.message : "Erreur inconnue"
      });
    }
  });
  
  app.get("/api/guides", async (req, res) => {
    try {
      const guides = await db.select().from(huntingGuides);
      res.json(guides);
    } catch (error) {
      console.error("Error fetching hunting guides:", error);
      res.status(500).json({ message: "Erreur lors de la r√©cup√©ration des guides de chasse" });
    }
  });

  // Return the HTTP server
  return createServer(app);
}
if (req.user?.role !== "admin") {
  return res.status(403).json({ message: "Action non autoris√©e" });
}

const userId = parseInt(req.params.id);

// V√©rifier que l'utilisateur existe
const user = await storage.getUser(userId);
if (!user) {
  return res.status(404).json({ message: "Utilisateur non trouv√©" });
}

// R√©activer l'utilisateur
const updatedUser = await storage.updateUser(userId, { isSuspended: false });

if (!updatedUser) {
  return res.status(500).json({ message: "√âchec de la r√©activation du compte" });
}

// Enregistrer dans l'historique
await storage.createHistory({
  userId: req.user?.id,
  operation: "update",
  entityType: "user",
  entityId: userId,
  details: `R√©activation du compte ${user.role}: ${user.username}`
});

res.status(200).json({ message: "Compte r√©activ√© avec succ√®s", user: updatedUser });
} catch (error) {
console.error("Erreur lors de la r√©activation du compte:", error);
res.status(500).json({ message: "√âchec de la r√©activation du compte" });
}
});

// Routes pour la gestion des permis suspendus
app.get("/api/permits/suspended", isAuthenticated, async (req, res) => {
try {
// V√©rifier les permissions (seuls admin et agents peuvent voir les permis suspendus)
if (req.user?.role !== "admin" && req.user?.role !== "agent" && req.user?.role !== "sub-agent") {
  return res.status(403).json({ message: "Acc√®s non autoris√©" });
}

// R√©cup√©rer tous les permis suspendus
const suspendedPermits = await storage.getSuspendedPermits();
res.json(suspendedPermits);
} catch (error) {
console.error("Erreur lors de la r√©cup√©ration des permis suspendus:", error);
res.status(500).json({ message: "Erreur serveur" });
}
});

app.delete("/api/permits/:id", isAuthenticated, async (req, res) => {
try {
// V√©rifier les permissions (seul admin peut supprimer un permis)
if (req.user?.role !== "admin") {
  return res.status(403).json({ message: "Acc√®s non autoris√©" });
}

const permitId = parseInt(req.params.id);
if (isNaN(permitId)) {
  return res.status(400).json({ message: "ID de permis invalide" });
}

// V√©rifier que le permis existe
const permit = await storage.getPermit(permitId);
if (!permit) {
  return res.status(404).json({ message: "Permis non trouv√©" });
}

// Supprimer le permis
const success = await storage.deletePermit(permitId);

if (!success) {
  return res.status(400).json({ 
    message: "Impossible de supprimer ce permis. Il pourrait avoir des taxes associ√©es." 
  });
}

// Enregistrer dans l'historique
await storage.createHistory({
  userId: req.user?.id,
  operation: "delete",
  entityType: "permit",
  entityId: permitId,
  details: `Suppression du permis ${permit.permitNumber}`
});

res.status(200).json({ message: "Permis supprim√© avec succ√®s" });
} catch (error) {
console.error("Erreur lors de la suppression du permis:", error);
res.status(500).json({ message: "Erreur serveur" });
}
});

app.delete("/api/permits/suspended/all", isAuthenticated, async (req, res) => {
try {
// V√©rifier les permissions (seul admin peut supprimer tous les permis suspendus)
if (req.user?.role !== "admin") {
  return res.status(403).json({ message: "Acc√®s non autoris√©" });
}

// Supprimer tous les permis suspendus
const deletedPermits = await storage.deleteAllSuspendedPermits();

// Enregistrer dans l'historique
await storage.createHistory({
  userId: req.user?.id,
  operation: "delete_multiple",
  entityType: "permit",
  entityId: 0,
  details: `Suppression de tous les permis suspendus (${deletedPermits.length} permis)`
});

res.status(200).json({ 
  message: `${deletedPermits.length} permis suspendus ont √©t√© supprim√©s avec succ√®s`
});
} catch (error) {
console.error("Erreur lors de la suppression des permis suspendus:", error);
res.status(500).json({ message: "Erreur serveur" });
}
});

app.delete("/api/permits/batch", isAuthenticated, async (req, res) => {
try {
// V√©rifier les permissions (seul admin peut supprimer des permis par lot)
if (req.user?.role !== "admin") {
  return res.status(403).json({ message: "Acc√®s non autoris√©" });
}

const { permitIds } = req.body;

if (!Array.isArray(permitIds) || permitIds.length === 0) {
  return res.status(400).json({ message: "Liste d'IDs de permis invalide ou vide" });
}

// Supprimer les permis par lot
const deletedPermits = await storage.deletePermitBatch(permitIds);

// Enregistrer dans l'historique
await storage.createHistory({
  userId: req.user?.id,
  operation: "delete_multiple",
  entityType: "permit",
  entityId: 0,
  details: `Suppression par lot de ${deletedPermits.length} permis`
});

res.status(200).json({ 
  message: `${deletedPermits.length} permis ont √©t√© supprim√©s avec succ√®s`
});
} catch (error) {
console.error("Erreur lors de la suppression par lot des permis:", error);
res.status(500).json({ message: "Erreur serveur" });
}
});

// Route pour servir la description du projet au format HTML (peut √™tre converti en PDF par le navigateur)
app.get("/project-description", (req, res) => {
const path = require('path');
res.sendFile(path.resolve('./project-description.html'));
});

// Routes pour les guides de chasse
app.get("/api/guides", async (req, res) => {
try {
  const guides = await db.select().from(huntingGuides);
  res.json(guides);
} catch (error) {
  console.error("Error fetching hunting guides:", error);
  res.status(500).json({ message: "Erreur lors de la r√©cup√©ration des guides de chasse" });
}
});

app.post("/api/guides", async (req, res) => {
try {
  console.log("Received hunting guide creation request:", req.body);

  // Valider les donn√©es avec le sch√©ma
  try {
    const validatedData = createHuntingGuideWithUserSchema.parse(req.body);

    // Cr√©er un nouvel utilisateur pour le guide
    const userData = {
      username: validatedData.username,
      password: validatedData.password,
      email: validatedData.email || 'guide@example.com',
      role: 'guide',
      firstName: validatedData.firstName,
      lastName: validatedData.lastName,
      phone: validatedData.phone,
      region: validatedData.region,
      serviceLocation: validatedData.zone,
      isActive: true,
      createdAt: new Date().toISOString()
    };

    // Cr√©er l'utilisateur
    const user = await storage.createUser(userData);

    // Cr√©er le guide de chasse
    const guideData = {
      userId: user.id,
      firstName: validatedData.firstName,
      lastName: validatedData.lastName,
      phone: validatedData.phone,
      zone: validatedData.zone,
      region: validatedData.region,
      idNumber: validatedData.idNumber,
      photo: validatedData.photo || null,
      status: 'active',
      createdAt: new Date().toISOString()
    };

    const guide = await db.insert(huntingGuides).values(guideData).returning();

    // Ajouter une entr√©e dans l'historique
    await storage.createHistory({
      userId: req.user?.id,
      operation: "create",
      entityType: "guide",
      entityId: guide[0].id,
      details: `Guide de chasse cr√©√©: ${guide[0].firstName} ${guide[0].lastName}`
    });

    res.status(201).json(guide[0]);
  } catch (validationError) {
    console.error("Guide validation error:", validationError);
    if (validationError instanceof z.ZodError) {
      return res.status(400).json({ 
        message: "Erreur de validation des donn√©es du guide", 
        errors: validationError.errors 
      });
    }
    throw validationError;
  }
} catch (error) {
  console.error("Guide creation error:", error);
  res.status(500).json({ 
    message: "√âchec de la cr√©ation du guide de chasse",
    error: error instanceof Error ? error.message : "Erreur inconnue"
  });
}
});

const httpServer = createServer(app);
return httpServer;